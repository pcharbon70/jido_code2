defmodule JidoCode.WorkflowRuntime.StepHandlers.CommitAndPR do
  @moduledoc """
  Handles the `CommitAndPR` shipping step branch setup and pre-ship policy phases.

  This MVP implementation derives deterministic run branch names using
  `jidocode/<workflow>/<short-run-id>`, attempts branch setup, and returns
  structured artifacts for downstream commit/push/PR phases.
  """

  @behaviour JidoCode.Forge.StepHandler

  @branch_pattern "jidocode/<workflow>/<short-run-id>"
  @branch_prefix "jidocode"
  @workflow_segment_fallback "workflow"
  @run_segment_fallback "run"
  @max_workflow_segment_length 32
  @max_short_run_id_length 24
  @hash_suffix_length 8
  @branch_collision_retry_suffix_length 8
  @branch_collision_retry_prefix "retry"
  @branch_collision_retry_limit 1
  @branch_collision_retry_strategy "deterministic_hash_suffix"
  @branch_collision_reason_fragments [
    "already exists",
    "already_exists",
    "branch exists",
    "branch_exists",
    "branch collision",
    "branch_collision",
    "reference already exists",
    "reference_exists",
    "remote branch exists",
    "remote_branch_exists",
    "name already in use"
  ]

  @branch_setup_error_type "workflow_commit_and_pr_branch_setup_failed"
  @branch_setup_operation "setup_run_branch"
  @branch_setup_remediation "Resolve branch creation preconditions and retry CommitAndPR shipping."
  @workspace_policy_error_type "workflow_commit_and_pr_workspace_policy_failed"
  @workspace_policy_operation "validate_workspace_cleanliness"
  @workspace_policy_stage "pre_ship_workspace_policy"
  @workspace_policy_remediation """
  Clean or discard unintended workspace changes, then retry CommitAndPR shipping.
  """
  @workspace_policy_check_id "workspace_cleanliness"
  @workspace_policy_check_name "Workspace cleanliness policy check"
  @workspace_policy_mode "clean_room"
  @required_workspace_state "clean"
  @secret_scan_policy_error_type "workflow_commit_and_pr_secret_scan_policy_failed"
  @secret_scan_policy_operation "validate_secret_scan"
  @secret_scan_policy_stage "pre_ship_secret_scan_policy"
  @secret_scan_policy_remediation """
  Remove detected secrets or restore secret-scan tooling health, then retry CommitAndPR shipping.
  """
  @secret_scan_check_id "secret_scan"
  @secret_scan_check_name "Secret scan policy check"
  @secret_scan_clean_state "clean"
  @secret_scan_violation_state "violations_detected"
  @secret_scan_tooling_error_state "tooling_error"
  @diff_size_policy_error_type "workflow_commit_and_pr_diff_size_policy_failed"
  @diff_size_policy_operation "validate_diff_size_threshold"
  @diff_size_policy_stage "pre_ship_diff_size_policy"
  @diff_size_policy_remediation """
  Split the change set into smaller commits or request explicit policy override, then retry CommitAndPR shipping.
  """
  @diff_size_check_id "diff_size_threshold"
  @diff_size_check_name "Diff size threshold policy check"
  @default_diff_max_changed_lines 800
  @binary_file_policy_error_type "workflow_commit_and_pr_binary_file_policy_failed"
  @binary_file_policy_operation "validate_binary_file_policy"
  @binary_file_policy_stage "pre_ship_binary_file_policy"
  @binary_file_policy_remediation """
  Remove or replace binary artifacts, or request explicit approval override per policy, then retry CommitAndPR shipping.
  """
  @binary_file_check_id "binary_file_policy"
  @binary_file_check_name "Binary file policy check"
  @default_binary_policy_on_detect "block"
  @commit_message_error_type "workflow_commit_and_pr_commit_message_contract_failed"
  @commit_message_operation "validate_commit_message_contract"
  @commit_message_stage "pre_ship_commit_message_contract"
  @commit_message_remediation """
  Regenerate commit message content to satisfy type/summary/body/trailer requirements, then retry CommitAndPR shipping.
  """
  @commit_message_check_id "commit_message_contract"
  @commit_message_check_name "Commit message contract check"
  @commit_message_type_fallback "chore"
  @commit_message_summary_fallback "apply workflow updates"
  @commit_message_body_fallback "Apply workflow-generated updates."
  @push_error_type "workflow_commit_and_pr_push_failed"
  @push_auth_error_type "workflow_commit_and_pr_push_auth_failed"
  @push_operation "push_run_branch"
  @push_stage "push_changes"
  @push_auth_retry_limit 1
  @push_auth_retry_strategy "refresh_github_auth_once"
  @push_auth_remediation """
  Refresh GitHub credentials, verify repository access, then retry CommitAndPR shipping.
  """
  @push_auth_reason_fragments [
    "auth",
    "authentication",
    "authorization",
    "unauthorized",
    "forbidden",
    "credential",
    "credentials",
    "token expired",
    "permission denied",
    "access denied",
    "insufficient permission"
  ]
  @commit_message_contract_pattern ~r/\A(?<commit_type>[a-z][a-z0-9_-]*): (?<summary>[^\n]+)\n\n(?<body>.+)\n\nGenerated by JidoCode workflow: (?<workflow_name>[^\n]+)\nRun ID: (?<run_id>[^\n]+)\z/s
  @binary_file_extensions ~w(
    .7z
    .a
    .avi
    .bin
    .bmp
    .class
    .dat
    .dll
    .dmg
    .doc
    .docx
    .eot
    .exe
    .gif
    .gz
    .ico
    .iso
    .jar
    .jpeg
    .jpg
    .mov
    .mp3
    .mp4
    .pdf
    .png
    .ppt
    .pptx
    .pyc
    .so
    .tar
    .ttf
    .wav
    .webm
    .webp
    .woff
    .woff2
    .xls
    .xlsx
    .zip
  )
  @blocked_shipping_actions ["commit", "push", "create_pr"]

  @impl true
  def execute(_sprite_client, args, opts) when is_map(args) and is_list(opts) do
    with {:ok, branch_context} <- derive_branch_context(args),
         {:ok, %{branch_context: resolved_branch_context, branch_setup: branch_setup}} <-
           setup_branch(branch_context, opts),
         {:ok, workspace_policy_check} <-
           validate_workspace_cleanliness(args, resolved_branch_context),
         {:ok, secret_scan_policy_check} <-
           validate_secret_scan(args, resolved_branch_context, opts),
         {:ok, diff_size_policy_check} <-
           validate_diff_size_threshold(args, resolved_branch_context, opts),
         {:ok, binary_file_policy_check} <-
           validate_binary_file_policy(args, resolved_branch_context, opts),
         {:ok, commit_message_contract_check} <-
           validate_commit_message_contract(args, resolved_branch_context, opts) do
      maybe_probe_commit(resolved_branch_context, opts)

      case maybe_execute_push(args, resolved_branch_context, branch_setup, opts) do
        {:ok, push_execution} ->
          {:ok,
           %{
             run_artifacts: %{
               branch_name: Map.fetch!(resolved_branch_context, :branch_name),
               branch_derivation: Map.fetch!(resolved_branch_context, :branch_derivation),
               commit_message: commit_message_artifact(commit_message_contract_check),
               commit_message_contract: commit_message_contract_check,
               collision_handling:
                 branch_setup
                 |> map_get(:collision_handling, "collision_handling")
                 |> normalize_map(),
               policy_checks: %{
                 workspace_cleanliness: workspace_policy_check,
                 secret_scan: secret_scan_policy_check,
                 diff_size_threshold: diff_size_policy_check,
                 binary_file_policy: binary_file_policy_check
               },
               push: Map.get(push_execution, :push, %{}),
               push_auth_recovery: Map.get(push_execution, :push_auth_recovery, %{}),
               run_logs: Map.get(push_execution, :run_logs, [])
             },
             branch_setup: branch_setup,
             commit_message: commit_message_artifact(commit_message_contract_check),
             commit_message_contract: commit_message_contract_check,
             policy_checks: %{
               workspace_cleanliness: workspace_policy_check,
               secret_scan: secret_scan_policy_check,
               diff_size_threshold: diff_size_policy_check,
               binary_file_policy: binary_file_policy_check
             },
             push: Map.get(push_execution, :push, %{}),
             push_auth_recovery: Map.get(push_execution, :push_auth_recovery, %{}),
             shipping_flow: Map.get(push_execution, :shipping_flow, %{}),
             run_logs: Map.get(push_execution, :run_logs, [])
           }}

        {:error, push_failure} ->
          {:error, push_failure}
      end
    end
  end

  def execute(_sprite_client, _args, _opts) do
    {:error,
     branch_setup_error(
       "invalid_arguments",
       "CommitAndPR shipping step requires map args.",
       nil
     )}
  end

  @doc false
  @spec default_branch_setup_runner(map()) :: {:ok, map()}
  def default_branch_setup_runner(branch_context) when is_map(branch_context) do
    {:ok,
     %{
       status: "created",
       adapter: "default_noop",
       command_intent: "git checkout -b #{Map.get(branch_context, :branch_name)}"
     }}
  end

  defp derive_branch_context(args) when is_map(args) do
    workflow_name =
      args |> map_get(:workflow_name, "workflow_name") |> normalize_optional_string()

    run_id = args |> map_get(:run_id, "run_id") |> normalize_optional_string()

    cond do
      is_nil(workflow_name) ->
        {:error,
         branch_setup_error(
           "workflow_name_missing",
           "CommitAndPR branch derivation requires workflow_name metadata.",
           nil
         )}

      is_nil(run_id) ->
        {:error,
         branch_setup_error(
           "run_id_missing",
           "CommitAndPR branch derivation requires run_id metadata.",
           nil
         )}

      true ->
        {workflow_segment, workflow_segment_strategy} =
          normalize_branch_segment(
            workflow_name,
            @workflow_segment_fallback,
            @max_workflow_segment_length
          )

        {short_run_id, short_run_id_strategy} =
          normalize_branch_segment(run_id, @run_segment_fallback, @max_short_run_id_length)

        branch_name = "#{@branch_prefix}/#{workflow_segment}/#{short_run_id}"

        {:ok,
         %{
           branch_name: branch_name,
           branch_derivation: %{
             pattern: @branch_pattern,
             workflow_name: workflow_name,
             workflow_segment: workflow_segment,
             workflow_segment_strategy: workflow_segment_strategy,
             run_id: run_id,
             short_run_id: short_run_id,
             short_run_id_strategy: short_run_id_strategy
           }
         }}
    end
  end

  defp derive_branch_context(_args) do
    {:error,
     branch_setup_error(
       "invalid_arguments",
       "CommitAndPR branch derivation requires map args.",
       nil
     )}
  end

  defp setup_branch(branch_context, opts) when is_map(branch_context) and is_list(opts) do
    branch_setup_runner =
      Keyword.get(opts, :branch_setup_runner, &__MODULE__.default_branch_setup_runner/1)

    if is_function(branch_setup_runner, 1) do
      safe_invoke_branch_setup_runner(branch_setup_runner, branch_context)
    else
      {:error,
       branch_setup_error(
         "branch_setup_runner_invalid",
         "CommitAndPR branch setup runner configuration is invalid.",
         branch_context
       )}
    end
  end

  defp setup_branch(branch_context, _opts) do
    {:error,
     branch_setup_error(
       "branch_setup_runner_invalid",
       "CommitAndPR branch setup runner configuration is invalid.",
       branch_context
     )}
  end

  defp safe_invoke_branch_setup_runner(branch_setup_runner, branch_context)
       when is_function(branch_setup_runner, 1) and is_map(branch_context) do
    case invoke_branch_setup_runner(branch_setup_runner, branch_context) do
      {:ok, branch_setup} ->
        {:ok, %{branch_context: branch_context, branch_setup: branch_setup}}

      {:error, first_failure} ->
        maybe_retry_branch_collision(
          branch_setup_runner,
          branch_context,
          normalize_map(first_failure)
        )
    end
  end

  defp maybe_retry_branch_collision(branch_setup_runner, branch_context, first_failure)
       when is_function(branch_setup_runner, 1) and is_map(branch_context) and
              is_map(first_failure) do
    first_failure_reason = map_get(first_failure, :reason, "reason")

    if branch_collision_reason?(first_failure_reason) do
      retry_branch_context = build_collision_retry_branch_context(branch_context, first_failure)

      case invoke_branch_setup_runner(branch_setup_runner, retry_branch_context) do
        {:ok, retry_branch_setup} ->
          {:ok,
           %{
             branch_context: retry_branch_context,
             branch_setup:
               merge_collision_retry_success(
                 retry_branch_setup,
                 branch_context,
                 retry_branch_context,
                 first_failure
               )
           }}

        {:error, retry_failure} ->
          {:error,
           branch_collision_retry_error(
             branch_context,
             retry_branch_context,
             first_failure,
             normalize_map(retry_failure)
           )}
      end
    else
      {:error,
       branch_setup_error(
         map_get(first_failure, :reason_type, "reason_type", "branch_setup_failed"),
         map_get(
           first_failure,
           :detail,
           "detail",
           "Run branch creation failed and shipping halted before commit."
         ),
         branch_context,
         first_failure_reason
       )}
    end
  end

  defp maybe_retry_branch_collision(_branch_setup_runner, branch_context, first_failure) do
    {:error,
     branch_setup_error(
       map_get(first_failure, :reason_type, "reason_type", "branch_setup_failed"),
       map_get(
         first_failure,
         :detail,
         "detail",
         "Run branch creation failed and shipping halted before commit."
       ),
       branch_context,
       map_get(first_failure, :reason, "reason")
     )}
  end

  defp invoke_branch_setup_runner(branch_setup_runner, branch_context)
       when is_function(branch_setup_runner, 1) and is_map(branch_context) do
    try do
      case branch_setup_runner.(branch_context) do
        :ok ->
          {:ok, %{status: "created"}}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} ->
          {:ok, %{status: "created", detail: "Branch setup runner returned #{inspect(result)}."}}

        {:error, reason} ->
          {:error,
           %{
             reason_type: "branch_setup_failed",
             detail: "Run branch creation failed and shipping halted before commit.",
             reason: reason
           }}

        other ->
          {:error,
           %{
             reason_type: "branch_setup_invalid_result",
             detail: "Branch setup runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "branch_setup_runner_crashed",
           detail: "Branch setup runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "branch_setup_runner_threw",
           detail: "Branch setup runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp build_collision_retry_branch_context(branch_context, first_failure)
       when is_map(branch_context) and is_map(first_failure) do
    source_branch_name =
      branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    retry_suffix = branch_collision_retry_suffix(source_branch_name)
    retry_branch_name = build_collision_retry_branch_name(source_branch_name, retry_suffix)

    branch_derivation =
      branch_context
      |> map_get(:branch_derivation, "branch_derivation")
      |> normalize_map()
      |> Map.put(:collision_retry_strategy, @branch_collision_retry_strategy)
      |> Map.put(:collision_retry_suffix, retry_suffix)
      |> Map.put(:collision_source_branch_name, source_branch_name)
      |> Map.put(:collision_retry_branch_name, retry_branch_name)
      |> Map.put(:collision_retry_attempt, 1)

    collision_handling =
      collision_handling_context(
        source_branch_name,
        retry_branch_name,
        first_failure,
        nil
      )

    branch_context
    |> Map.put(:branch_name, retry_branch_name)
    |> Map.put(:branch_derivation, branch_derivation)
    |> Map.put(:collision_handling, collision_handling)
  end

  defp build_collision_retry_branch_context(branch_context, _first_failure), do: branch_context

  defp merge_collision_retry_success(
         retry_branch_setup,
         branch_context,
         retry_branch_context,
         first_failure
       )
       when is_map(retry_branch_context) and is_map(first_failure) do
    source_branch_name =
      branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    retry_branch_name =
      retry_branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    retry_branch_setup
    |> normalize_map()
    |> Map.put(:status, "created_after_collision_retry")
    |> Map.put(:branch_name, retry_branch_name)
    |> Map.put(
      :collision_handling,
      collision_handling_context(source_branch_name, retry_branch_name, first_failure, nil)
    )
  end

  defp merge_collision_retry_success(
         retry_branch_setup,
         _branch_context,
         _retry_branch_context,
         _first_failure
       ),
       do: normalize_map(retry_branch_setup)

  defp branch_collision_retry_error(
         branch_context,
         retry_branch_context,
         first_failure,
         retry_failure
       )
       when is_map(branch_context) and is_map(retry_branch_context) and is_map(first_failure) and
              is_map(retry_failure) do
    source_branch_name =
      branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    retry_branch_name =
      retry_branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    retry_reason = map_get(retry_failure, :reason, "reason")

    branch_setup_error(
      "branch_collision_retry_failed",
      "Run branch collision retry failed and shipping halted before commit.",
      retry_branch_context,
      retry_reason
    )
    |> Map.merge(%{
      collision_handling:
        collision_handling_context(
          source_branch_name,
          retry_branch_name,
          first_failure,
          retry_failure
        ),
      source_branch_name: source_branch_name,
      retry_branch_name: retry_branch_name
    })
  end

  defp branch_collision_reason?(reason) do
    reason
    |> collision_reason_fragments()
    |> Enum.any?(fn fragment ->
      Enum.any?(@branch_collision_reason_fragments, &String.contains?(fragment, &1))
    end)
  end

  defp collision_reason_fragments(reason) when is_map(reason) do
    [
      map_get(reason, :reason_type, "reason_type"),
      map_get(reason, :error_type, "error_type"),
      map_get(reason, :detail, "detail"),
      map_get(reason, :message, "message"),
      map_get(reason, :reason, "reason")
    ]
    |> Enum.flat_map(&collision_reason_fragments/1)
  end

  defp collision_reason_fragments(reason) when is_tuple(reason) do
    reason |> Tuple.to_list() |> Enum.flat_map(&collision_reason_fragments/1)
  end

  defp collision_reason_fragments(reason) when is_list(reason),
    do: Enum.flat_map(reason, &collision_reason_fragments/1)

  defp collision_reason_fragments(reason) when is_atom(reason) do
    reason |> Atom.to_string() |> collision_reason_fragments()
  end

  defp collision_reason_fragments(reason) when is_binary(reason) do
    [String.downcase(reason)]
  end

  defp collision_reason_fragments(reason) do
    case normalize_optional_string(format_failure_reason(reason)) do
      nil -> []
      formatted_reason -> [String.downcase(formatted_reason)]
    end
  rescue
    _exception -> []
  end

  defp branch_collision_retry_suffix(branch_name)
       when is_binary(branch_name) and branch_name != "" do
    hash =
      "collision:#{branch_name}"
      |> then(&:crypto.hash(:sha256, &1))
      |> Base.encode16(case: :lower)
      |> String.slice(0, @branch_collision_retry_suffix_length)

    "#{@branch_collision_retry_prefix}-#{hash}"
  end

  defp branch_collision_retry_suffix(_branch_name) do
    random_fallback =
      "collision:fallback"
      |> then(&:crypto.hash(:sha256, &1))
      |> Base.encode16(case: :lower)
      |> String.slice(0, @branch_collision_retry_suffix_length)

    "#{@branch_collision_retry_prefix}-#{random_fallback}"
  end

  defp build_collision_retry_branch_name(source_branch_name, retry_suffix)
       when is_binary(source_branch_name) and source_branch_name != "" and is_binary(retry_suffix) and
              retry_suffix != "" do
    "#{source_branch_name}-#{retry_suffix}"
  end

  defp build_collision_retry_branch_name(source_branch_name, _retry_suffix),
    do: source_branch_name

  defp collision_handling_context(
         source_branch_name,
         retry_branch_name,
         first_failure,
         retry_failure
       )
       when is_map(first_failure) do
    %{
      collision_detected: true,
      strategy: @branch_collision_retry_strategy,
      retry_limit: @branch_collision_retry_limit,
      retry_attempted: true,
      source_branch_name: source_branch_name,
      retry_branch_name: retry_branch_name,
      overwrite_existing_remote: false,
      force_push: false,
      initial_reason_type: first_failure |> map_get(:reason_type, "reason_type") |> normalize_reason_type(),
      initial_reason: first_failure |> map_get(:reason, "reason") |> format_failure_reason()
    }
    |> maybe_add_retry_failure_context(retry_failure)
  end

  defp collision_handling_context(
         source_branch_name,
         retry_branch_name,
         _first_failure,
         _retry_failure
       ) do
    %{
      collision_detected: true,
      strategy: @branch_collision_retry_strategy,
      retry_limit: @branch_collision_retry_limit,
      retry_attempted: true,
      source_branch_name: source_branch_name,
      retry_branch_name: retry_branch_name,
      overwrite_existing_remote: false,
      force_push: false
    }
  end

  defp maybe_add_retry_failure_context(collision_handling_context, retry_failure)
       when is_map(collision_handling_context) and is_map(retry_failure) do
    collision_handling_context
    |> Map.put(
      :retry_failure_reason_type,
      retry_failure |> map_get(:reason_type, "reason_type") |> normalize_reason_type()
    )
    |> Map.put(
      :retry_failure_reason,
      retry_failure |> map_get(:reason, "reason") |> format_failure_reason()
    )
  end

  defp maybe_add_retry_failure_context(collision_handling_context, _retry_failure),
    do: collision_handling_context

  defp validate_workspace_cleanliness(args, branch_context)
       when is_map(args) and is_map(branch_context) do
    workspace_policy_check = build_workspace_policy_check(args, branch_context)

    if workspace_policy_check.status == "passed" do
      {:ok, workspace_policy_check}
    else
      {:error,
       workspace_policy_error(
         workspace_policy_reason_type(workspace_policy_check),
         Map.get(
           workspace_policy_check,
           :detail,
           "Workspace cleanliness policy blocked shipping."
         ),
         branch_context,
         workspace_policy_check
       )}
    end
  end

  defp validate_workspace_cleanliness(_args, branch_context) do
    fallback_policy_check =
      %{
        id: @workspace_policy_check_id,
        name: @workspace_policy_check_name,
        status: "failed",
        policy_mode: @workspace_policy_mode,
        required_state: @required_workspace_state,
        observed_state: "unknown",
        environment_mode: "cloud",
        detail: "Workspace cleanliness state is unavailable and shipping is blocked.",
        remediation: @workspace_policy_remediation,
        run_metadata: %{},
        step_metadata: default_step_metadata(),
        checked_at: timestamp_now()
      }

    {:error,
     workspace_policy_error(
       "workspace_state_unknown",
       "Workspace cleanliness state is unavailable and shipping is blocked.",
       branch_context,
       fallback_policy_check
     )}
  end

  @doc false
  @spec default_secret_scan_runner(map(), map()) :: {:ok, map()} | {:error, map()}
  def default_secret_scan_runner(args, _branch_context) when is_map(args) do
    case secret_scan_signal_from_args(args) do
      {:passed, _violation_count, _findings} ->
        {:ok,
         %{
           status: "passed",
           scan_status: @secret_scan_clean_state,
           violation_count: 0,
           findings: [],
           detail: "Secret scan passed with no detected plaintext secrets."
         }}

      {:violation, violation_count, findings} ->
        {:ok,
         %{
           status: "failed",
           scan_status: @secret_scan_violation_state,
           violation_count: violation_count,
           findings: findings,
           detail: "Secret scan detected potential plaintext secrets and blocked shipping."
         }}

      {:tooling_error, reason} ->
        {:error,
         %{
           reason_type: "secret_scan_tooling_error",
           detail: "Secret scan tooling failed and shipping is blocked by fail-closed policy.",
           reason: reason
         }}
    end
  end

  def default_secret_scan_runner(_args, _branch_context) do
    {:error,
     %{
       reason_type: "secret_scan_tooling_error",
       detail: "Secret scan input payload is invalid and shipping is blocked by fail-closed policy.",
       reason: :invalid_secret_scan_args
     }}
  end

  defp validate_secret_scan(args, branch_context, opts)
       when is_map(args) and is_map(branch_context) and is_list(opts) do
    secret_scan_runner =
      Keyword.get(opts, :secret_scan_runner, &__MODULE__.default_secret_scan_runner/2)

    case invoke_secret_scan_runner(secret_scan_runner, args, branch_context) do
      {:ok, secret_scan_result} ->
        secret_scan_policy_check =
          build_secret_scan_policy_check(args, branch_context, secret_scan_result)

        if secret_scan_policy_check.status == "passed" do
          {:ok, secret_scan_policy_check}
        else
          {:error,
           secret_scan_policy_error(
             "policy_violation",
             Map.get(secret_scan_policy_check, :detail, "Secret scan policy blocked shipping."),
             branch_context,
             secret_scan_policy_check,
             map_get(secret_scan_result, :reason, "reason")
           )}
        end

      {:error, secret_scan_runner_failure} ->
        secret_scan_policy_check =
          build_secret_scan_tooling_failure_policy_check(
            args,
            branch_context,
            secret_scan_runner_failure
          )

        {:error,
         secret_scan_policy_error(
           "policy_violation",
           Map.get(
             secret_scan_policy_check,
             :detail,
             "Secret scan tooling failed and shipping is blocked by fail-closed policy."
           ),
           branch_context,
           secret_scan_policy_check,
           secret_scan_runner_failure
         )}
    end
  end

  defp validate_secret_scan(_args, branch_context, _opts) do
    secret_scan_policy_check =
      build_secret_scan_tooling_failure_policy_check(
        %{},
        branch_context,
        :invalid_secret_scan_args
      )

    {:error,
     secret_scan_policy_error(
       "policy_violation",
       Map.get(
         secret_scan_policy_check,
         :detail,
         "Secret scan tooling failed and shipping is blocked by fail-closed policy."
       ),
       branch_context,
       secret_scan_policy_check,
       :invalid_secret_scan_args
     )}
  end

  defp invoke_secret_scan_runner(secret_scan_runner, args, branch_context)
       when is_function(secret_scan_runner, 2) and is_map(args) and is_map(branch_context) do
    safe_invoke_secret_scan_runner(secret_scan_runner, args, branch_context)
  end

  defp invoke_secret_scan_runner(secret_scan_runner, args, branch_context)
       when is_function(secret_scan_runner, 1) and is_map(args) and is_map(branch_context) do
    safe_invoke_secret_scan_runner(
      fn _args, context -> secret_scan_runner.(context) end,
      args,
      branch_context
    )
  end

  defp invoke_secret_scan_runner(_secret_scan_runner, _args, _branch_context) do
    {:error,
     %{
       reason_type: "secret_scan_runner_invalid",
       detail: "Secret scan runner configuration is invalid."
     }}
  end

  defp safe_invoke_secret_scan_runner(secret_scan_runner, args, branch_context)
       when is_function(secret_scan_runner, 2) and is_map(args) and is_map(branch_context) do
    try do
      case secret_scan_runner.(args, branch_context) do
        :ok ->
          {:ok, %{status: "passed", scan_status: @secret_scan_clean_state}}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} ->
          {:ok, %{status: "passed", scan_status: @secret_scan_clean_state, detail: inspect(result)}}

        {:error, reason} ->
          {:error, reason}

        other ->
          {:error,
           %{
             reason_type: "secret_scan_invalid_result",
             detail: "Secret scan runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "secret_scan_runner_crashed",
           detail: "Secret scan runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "secret_scan_runner_threw",
           detail: "Secret scan runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp build_secret_scan_policy_check(args, branch_context, secret_scan_result)
       when is_map(args) and is_map(branch_context) and is_map(secret_scan_result) do
    environment_mode = environment_mode_from_args(args)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    status =
      secret_scan_result
      |> map_get(:status, "status")
      |> normalize_secret_scan_check_status()
      |> case do
        "passed" -> "passed"
        "failed" -> "failed"
        _other -> "failed"
      end

    scan_status = normalize_secret_scan_outcome(secret_scan_result, status)

    findings =
      secret_scan_result |> map_get(:findings, "findings") |> normalize_secret_scan_findings()

    violation_count =
      secret_scan_result
      |> map_get(:violation_count, "violation_count")
      |> normalize_secret_scan_violation_count(length(findings))
      |> normalize_violation_count(status, findings)

    blocked_actions = secret_scan_blocked_actions(status)

    %{
      id: @secret_scan_check_id,
      name: @secret_scan_check_name,
      status: status,
      scan_status: scan_status,
      violation_count: violation_count,
      findings: findings,
      blocked_actions: blocked_actions,
      blocked_action_details: secret_scan_blocked_action_details(scan_status, blocked_actions),
      detail:
        secret_scan_result
        |> map_get(
          :detail,
          "detail",
          secret_scan_policy_detail(status, scan_status, violation_count)
        )
        |> normalize_optional_string() ||
          secret_scan_policy_detail(status, scan_status, violation_count),
      remediation:
        secret_scan_result
        |> map_get(
          :remediation,
          "remediation",
          secret_scan_policy_remediation(status, scan_status)
        )
        |> normalize_optional_string() || secret_scan_policy_remediation(status, scan_status),
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: secret_scan_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_secret_scan_policy_check(_args, branch_context, _secret_scan_result) do
    build_secret_scan_tooling_failure_policy_check(
      %{},
      branch_context,
      :invalid_secret_scan_result
    )
  end

  defp build_secret_scan_tooling_failure_policy_check(args, branch_context, reason)
       when is_map(args) and is_map(branch_context) do
    environment_mode = environment_mode_from_args(args)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    detail =
      map_get(
        reason,
        :detail,
        "detail",
        "Secret scan tooling failed and shipping is blocked by fail-closed policy."
      )

    %{
      id: @secret_scan_check_id,
      name: @secret_scan_check_name,
      status: "failed",
      scan_status: @secret_scan_tooling_error_state,
      violation_count: 0,
      findings: [],
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details:
        secret_scan_blocked_action_details(
          @secret_scan_tooling_error_state,
          @blocked_shipping_actions
        ),
      detail: detail,
      remediation: @secret_scan_policy_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: secret_scan_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_secret_scan_tooling_failure_policy_check(_args, branch_context, _reason) do
    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @secret_scan_check_id,
      name: @secret_scan_check_name,
      status: "failed",
      scan_status: @secret_scan_tooling_error_state,
      violation_count: 0,
      findings: [],
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details:
        secret_scan_blocked_action_details(
          @secret_scan_tooling_error_state,
          @blocked_shipping_actions
        ),
      detail: "Secret scan tooling failed and shipping is blocked by fail-closed policy.",
      remediation: @secret_scan_policy_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: "cloud"
      },
      step_metadata: secret_scan_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  @doc false
  @spec default_diff_size_runner(map(), map()) :: {:ok, map()} | {:error, map()}
  def default_diff_size_runner(args, _branch_context) when is_map(args) do
    {:ok, diff_metrics_from_sources(args, %{})}
  end

  def default_diff_size_runner(_args, _branch_context) do
    {:error,
     %{
       reason_type: "diff_size_input_invalid",
       detail: "Diff size input payload is invalid and shipping is blocked by fail-closed policy.",
       reason: :invalid_diff_size_args
     }}
  end

  defp validate_diff_size_threshold(args, branch_context, opts)
       when is_map(args) and is_map(branch_context) and is_list(opts) do
    diff_size_runner =
      Keyword.get(opts, :diff_size_runner, &__MODULE__.default_diff_size_runner/2)

    case invoke_diff_size_runner(diff_size_runner, args, branch_context) do
      {:ok, diff_size_result} ->
        diff_size_policy_check =
          build_diff_size_policy_check(args, branch_context, diff_size_result)

        if diff_size_policy_check.status == "passed" do
          {:ok, diff_size_policy_check}
        else
          {:error,
           diff_size_policy_error(
             diff_size_reason_type(diff_size_policy_check),
             Map.get(
               diff_size_policy_check,
               :detail,
               "Diff size threshold policy blocked shipping."
             ),
             branch_context,
             diff_size_policy_check,
             map_get(diff_size_result, :reason, "reason")
           )}
        end

      {:error, diff_size_runner_failure} ->
        diff_size_policy_check =
          build_diff_size_tooling_failure_policy_check(
            args,
            branch_context,
            diff_size_runner_failure
          )

        {:error,
         diff_size_policy_error(
           "policy_violation",
           Map.get(
             diff_size_policy_check,
             :detail,
             "Diff size metrics are unavailable and shipping is blocked by fail-closed policy."
           ),
           branch_context,
           diff_size_policy_check,
           diff_size_runner_failure
         )}
    end
  end

  defp validate_diff_size_threshold(_args, branch_context, _opts) do
    diff_size_policy_check =
      build_diff_size_tooling_failure_policy_check(
        %{},
        branch_context,
        :invalid_diff_size_args
      )

    {:error,
     diff_size_policy_error(
       "policy_violation",
       Map.get(
         diff_size_policy_check,
         :detail,
         "Diff size metrics are unavailable and shipping is blocked by fail-closed policy."
       ),
       branch_context,
       diff_size_policy_check,
       :invalid_diff_size_args
     )}
  end

  defp invoke_diff_size_runner(diff_size_runner, args, branch_context)
       when is_function(diff_size_runner, 2) and is_map(args) and is_map(branch_context) do
    safe_invoke_diff_size_runner(diff_size_runner, args, branch_context)
  end

  defp invoke_diff_size_runner(diff_size_runner, args, branch_context)
       when is_function(diff_size_runner, 1) and is_map(args) and is_map(branch_context) do
    safe_invoke_diff_size_runner(
      fn _args, context -> diff_size_runner.(context) end,
      args,
      branch_context
    )
  end

  defp invoke_diff_size_runner(_diff_size_runner, _args, _branch_context) do
    {:error,
     %{
       reason_type: "diff_size_runner_invalid",
       detail: "Diff size runner configuration is invalid."
     }}
  end

  defp safe_invoke_diff_size_runner(diff_size_runner, args, branch_context)
       when is_function(diff_size_runner, 2) and is_map(args) and is_map(branch_context) do
    try do
      case diff_size_runner.(args, branch_context) do
        :ok ->
          {:ok, diff_metrics_from_sources(args, %{})}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} when is_integer(result) and result >= 0 ->
          {:ok, %{total_lines_changed: result}}

        {:ok, result} ->
          {:error,
           %{
             reason_type: "diff_size_invalid_result",
             detail: "Diff size runner returned an invalid result (#{inspect(result)}).",
             reason: result
           }}

        {:error, reason} ->
          {:error, reason}

        other ->
          {:error,
           %{
             reason_type: "diff_size_invalid_result",
             detail: "Diff size runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "diff_size_runner_crashed",
           detail: "Diff size runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "diff_size_runner_threw",
           detail: "Diff size runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp build_diff_size_policy_check(args, branch_context, diff_size_result)
       when is_map(args) and is_map(branch_context) and is_map(diff_size_result) do
    environment_mode = environment_mode_from_args(args)
    diff_metrics = diff_metrics_from_sources(args, diff_size_result)
    threshold_policy = diff_threshold_policy(args, diff_size_result)

    total_lines_changed = Map.get(diff_metrics, :total_lines_changed, 0)

    max_changed_lines =
      Map.get(threshold_policy, :max_changed_lines, @default_diff_max_changed_lines)

    threshold_exceeded = total_lines_changed > max_changed_lines

    decision = diff_size_decision(threshold_exceeded, Map.get(threshold_policy, :on_exceed))
    status = if threshold_exceeded, do: "failed", else: "passed"
    blocked_actions = diff_size_blocked_actions(status)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @diff_size_check_id,
      name: @diff_size_check_name,
      status: status,
      decision: decision,
      threshold_exceeded: threshold_exceeded,
      manual_override_required: decision == "approval_override_required",
      metrics: diff_metrics,
      threshold_policy: threshold_policy,
      blocked_actions: blocked_actions,
      blocked_action_details: diff_size_blocked_action_details(decision, blocked_actions),
      detail:
        diff_size_result
        |> map_get(
          :detail,
          "detail",
          diff_size_policy_detail(
            status,
            decision,
            total_lines_changed,
            max_changed_lines,
            Map.get(threshold_policy, :source)
          )
        )
        |> normalize_optional_string() ||
          diff_size_policy_detail(
            status,
            decision,
            total_lines_changed,
            max_changed_lines,
            Map.get(threshold_policy, :source)
          ),
      remediation:
        diff_size_result
        |> map_get(
          :remediation,
          "remediation",
          diff_size_policy_remediation(status, decision)
        )
        |> normalize_optional_string() || diff_size_policy_remediation(status, decision),
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: diff_size_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_diff_size_policy_check(_args, branch_context, _diff_size_result) do
    build_diff_size_tooling_failure_policy_check(
      %{},
      branch_context,
      :invalid_diff_size_result
    )
  end

  defp build_diff_size_tooling_failure_policy_check(args, branch_context, reason)
       when is_map(args) and is_map(branch_context) do
    environment_mode = environment_mode_from_args(args)
    threshold_policy = diff_threshold_policy(args, %{})
    diff_metrics = diff_metrics_from_sources(args, %{})

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    detail =
      map_get(
        reason,
        :detail,
        "detail",
        "Diff size metrics are unavailable and shipping is blocked by fail-closed policy."
      )

    %{
      id: @diff_size_check_id,
      name: @diff_size_check_name,
      status: "failed",
      decision: "blocked",
      threshold_exceeded: false,
      manual_override_required: false,
      metrics: diff_metrics,
      threshold_policy: threshold_policy,
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details: diff_size_blocked_action_details("tooling_error", @blocked_shipping_actions),
      detail: detail,
      remediation: @diff_size_policy_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: diff_size_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_diff_size_tooling_failure_policy_check(_args, branch_context, _reason) do
    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @diff_size_check_id,
      name: @diff_size_check_name,
      status: "failed",
      decision: "blocked",
      threshold_exceeded: false,
      manual_override_required: false,
      metrics: %{files_changed: 0, lines_added: 0, lines_deleted: 0, total_lines_changed: 0},
      threshold_policy: default_diff_threshold_policy(),
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details: diff_size_blocked_action_details("tooling_error", @blocked_shipping_actions),
      detail: "Diff size metrics are unavailable and shipping is blocked by fail-closed policy.",
      remediation: @diff_size_policy_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: "cloud"
      },
      step_metadata: diff_size_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  @doc false
  @spec default_binary_file_runner(map(), map()) :: {:ok, map()} | {:error, map()}
  def default_binary_file_runner(args, _branch_context) when is_map(args) do
    {:ok, binary_detection_from_sources(args, %{})}
  end

  def default_binary_file_runner(_args, _branch_context) do
    {:error,
     %{
       reason_type: "binary_file_policy_input_invalid",
       detail: "Binary file policy input payload is invalid and shipping is blocked by fail-closed policy.",
       reason: :invalid_binary_policy_args
     }}
  end

  defp validate_binary_file_policy(args, branch_context, opts)
       when is_map(args) and is_map(branch_context) and is_list(opts) do
    binary_file_runner =
      Keyword.get(opts, :binary_file_runner, &__MODULE__.default_binary_file_runner/2)

    case invoke_binary_file_runner(binary_file_runner, args, branch_context) do
      {:ok, binary_file_result} ->
        binary_file_policy_check =
          build_binary_file_policy_check(args, branch_context, binary_file_result)

        if binary_file_policy_check.status == "passed" do
          {:ok, binary_file_policy_check}
        else
          {:error,
           binary_file_policy_error(
             binary_file_reason_type(binary_file_policy_check),
             Map.get(
               binary_file_policy_check,
               :detail,
               "Binary file policy blocked shipping."
             ),
             branch_context,
             binary_file_policy_check,
             map_get(binary_file_result, :reason, "reason")
           )}
        end

      {:error, binary_file_runner_failure} ->
        binary_file_policy_check =
          build_binary_file_tooling_failure_policy_check(
            args,
            branch_context,
            binary_file_runner_failure
          )

        {:error,
         binary_file_policy_error(
           "policy_violation",
           Map.get(
             binary_file_policy_check,
             :detail,
             "Binary file policy evaluation failed and shipping is blocked by fail-closed policy."
           ),
           branch_context,
           binary_file_policy_check,
           binary_file_runner_failure
         )}
    end
  end

  defp validate_binary_file_policy(_args, branch_context, _opts) do
    binary_file_policy_check =
      build_binary_file_tooling_failure_policy_check(
        %{},
        branch_context,
        :invalid_binary_policy_args
      )

    {:error,
     binary_file_policy_error(
       "policy_violation",
       Map.get(
         binary_file_policy_check,
         :detail,
         "Binary file policy evaluation failed and shipping is blocked by fail-closed policy."
       ),
       branch_context,
       binary_file_policy_check,
       :invalid_binary_policy_args
     )}
  end

  defp invoke_binary_file_runner(binary_file_runner, args, branch_context)
       when is_function(binary_file_runner, 2) and is_map(args) and is_map(branch_context) do
    safe_invoke_binary_file_runner(binary_file_runner, args, branch_context)
  end

  defp invoke_binary_file_runner(binary_file_runner, args, branch_context)
       when is_function(binary_file_runner, 1) and is_map(args) and is_map(branch_context) do
    safe_invoke_binary_file_runner(
      fn _args, context -> binary_file_runner.(context) end,
      args,
      branch_context
    )
  end

  defp invoke_binary_file_runner(_binary_file_runner, _args, _branch_context) do
    {:error,
     %{
       reason_type: "binary_file_runner_invalid",
       detail: "Binary file policy runner configuration is invalid."
     }}
  end

  defp safe_invoke_binary_file_runner(binary_file_runner, args, branch_context)
       when is_function(binary_file_runner, 2) and is_map(args) and is_map(branch_context) do
    try do
      case binary_file_runner.(args, branch_context) do
        :ok ->
          {:ok, binary_detection_from_sources(args, %{})}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} when is_list(result) ->
          {:ok, %{staged_files: result}}

        {:ok, result} when is_binary(result) ->
          {:ok, %{staged_files: [result]}}

        {:ok, result} ->
          {:error,
           %{
             reason_type: "binary_file_invalid_result",
             detail: "Binary file runner returned an invalid result (#{inspect(result)}).",
             reason: result
           }}

        {:error, reason} ->
          {:error, reason}

        other ->
          {:error,
           %{
             reason_type: "binary_file_invalid_result",
             detail: "Binary file runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "binary_file_runner_crashed",
           detail: "Binary file runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "binary_file_runner_threw",
           detail: "Binary file runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp build_binary_file_policy_check(args, branch_context, binary_file_result)
       when is_map(args) and is_map(branch_context) and is_map(binary_file_result) do
    environment_mode = environment_mode_from_args(args)
    detection = binary_detection_from_sources(args, binary_file_result)
    binary_policy = binary_file_policy(args, binary_file_result)

    binary_file_count = Map.get(detection, :binary_file_count, 0)
    decision = binary_file_decision(binary_file_count, Map.get(binary_policy, :on_detect))
    status = binary_file_status(binary_file_count, decision)
    blocked_actions = binary_file_blocked_actions(status)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @binary_file_check_id,
      name: @binary_file_check_name,
      status: status,
      decision: decision,
      binary_detected: binary_file_count > 0,
      binary_file_count: binary_file_count,
      binary_files: Map.get(detection, :binary_files, []),
      detection: detection,
      binary_policy: binary_policy,
      blocked_actions: blocked_actions,
      blocked_action_details: binary_file_blocked_action_details(decision, blocked_actions),
      detail:
        binary_file_result
        |> map_get(
          :detail,
          "detail",
          binary_file_policy_detail(
            status,
            decision,
            binary_file_count,
            Map.get(binary_policy, :source)
          )
        )
        |> normalize_optional_string() ||
          binary_file_policy_detail(
            status,
            decision,
            binary_file_count,
            Map.get(binary_policy, :source)
          ),
      remediation:
        binary_file_result
        |> map_get(
          :remediation,
          "remediation",
          binary_file_policy_remediation(status, decision)
        )
        |> normalize_optional_string() || binary_file_policy_remediation(status, decision),
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: binary_file_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_binary_file_policy_check(_args, branch_context, _binary_file_result) do
    build_binary_file_tooling_failure_policy_check(
      %{},
      branch_context,
      :invalid_binary_file_result
    )
  end

  defp build_binary_file_tooling_failure_policy_check(args, branch_context, reason)
       when is_map(args) and is_map(branch_context) do
    environment_mode = environment_mode_from_args(args)
    detection = binary_detection_from_sources(args, %{})
    binary_policy = binary_file_policy(args, %{})

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    detail =
      map_get(
        reason,
        :detail,
        "detail",
        "Binary file policy evaluation failed and shipping is blocked by fail-closed policy."
      )

    %{
      id: @binary_file_check_id,
      name: @binary_file_check_name,
      status: "failed",
      decision: "blocked",
      binary_detected: Map.get(detection, :binary_detected, false),
      binary_file_count: Map.get(detection, :binary_file_count, 0),
      binary_files: Map.get(detection, :binary_files, []),
      detection: detection,
      binary_policy: binary_policy,
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details: binary_file_blocked_action_details("tooling_error", @blocked_shipping_actions),
      detail: detail,
      remediation: @binary_file_policy_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: binary_file_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_binary_file_tooling_failure_policy_check(_args, branch_context, _reason) do
    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @binary_file_check_id,
      name: @binary_file_check_name,
      status: "failed",
      decision: "blocked",
      binary_detected: false,
      binary_file_count: 0,
      binary_files: [],
      detection: %{
        staged_files: [],
        staged_file_count: 0,
        binary_files: [],
        binary_file_count: 0,
        binary_detected: false,
        detection_source: "none"
      },
      binary_policy: default_binary_file_policy(),
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details: binary_file_blocked_action_details("tooling_error", @blocked_shipping_actions),
      detail: "Binary file policy evaluation failed and shipping is blocked by fail-closed policy.",
      remediation: @binary_file_policy_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: "cloud"
      },
      step_metadata: binary_file_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  @doc false
  @spec default_commit_message_runner(map(), map()) :: {:ok, map()} | {:error, map()}
  def default_commit_message_runner(args, branch_context)
      when is_map(args) and is_map(branch_context) do
    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    workflow_name =
      branch_derivation
      |> map_get(:workflow_name, "workflow_name")
      |> normalize_optional_string()

    run_id =
      branch_derivation
      |> map_get(:run_id, "run_id")
      |> normalize_optional_string()

    commit_type = commit_type_from_args(args)
    summary = commit_summary_from_args(args, workflow_name)
    body = commit_body_from_args(args, workflow_name)

    message = compose_commit_message(commit_type, summary, body, workflow_name, run_id)

    {:ok,
     %{
       message: message,
       commit_type: commit_type,
       summary: summary,
       body: body
     }}
  end

  def default_commit_message_runner(_args, _branch_context) do
    {:error,
     %{
       reason_type: "commit_message_input_invalid",
       detail: "Commit message generation inputs are invalid and shipping is blocked by fail-closed policy.",
       reason: :invalid_commit_message_args
     }}
  end

  defp validate_commit_message_contract(args, branch_context, opts)
       when is_map(args) and is_map(branch_context) and is_list(opts) do
    commit_message_runner =
      Keyword.get(opts, :commit_message_runner, &__MODULE__.default_commit_message_runner/2)

    case invoke_commit_message_runner(commit_message_runner, args, branch_context) do
      {:ok, commit_message_result} ->
        commit_message_check =
          build_commit_message_contract_check(args, branch_context, commit_message_result)

        if commit_message_check.status == "passed" do
          {:ok, commit_message_check}
        else
          {:error,
           commit_message_contract_error(
             commit_message_reason_type(commit_message_check),
             Map.get(
               commit_message_check,
               :detail,
               "Commit message failed required contract validation."
             ),
             branch_context,
             commit_message_check
           )}
        end

      {:error, commit_message_runner_failure} ->
        commit_message_check =
          build_commit_message_tooling_failure_check(
            args,
            branch_context,
            commit_message_runner_failure
          )

        {:error,
         commit_message_contract_error(
           "commit_message_generation_failed",
           Map.get(
             commit_message_check,
             :detail,
             "Commit message generation failed and shipping is blocked by fail-closed policy."
           ),
           branch_context,
           commit_message_check,
           commit_message_runner_failure
         )}
    end
  end

  defp validate_commit_message_contract(_args, branch_context, _opts) do
    commit_message_check =
      build_commit_message_tooling_failure_check(
        %{},
        branch_context,
        :invalid_commit_message_args
      )

    {:error,
     commit_message_contract_error(
       "commit_message_generation_failed",
       Map.get(
         commit_message_check,
         :detail,
         "Commit message generation failed and shipping is blocked by fail-closed policy."
       ),
       branch_context,
       commit_message_check,
       :invalid_commit_message_args
     )}
  end

  defp invoke_commit_message_runner(commit_message_runner, args, branch_context)
       when is_function(commit_message_runner, 2) and is_map(args) and is_map(branch_context) do
    safe_invoke_commit_message_runner(commit_message_runner, args, branch_context)
  end

  defp invoke_commit_message_runner(commit_message_runner, args, branch_context)
       when is_function(commit_message_runner, 1) and is_map(args) and is_map(branch_context) do
    safe_invoke_commit_message_runner(
      fn _args, context -> commit_message_runner.(context) end,
      args,
      branch_context
    )
  end

  defp invoke_commit_message_runner(_commit_message_runner, _args, _branch_context) do
    {:error,
     %{
       reason_type: "commit_message_runner_invalid",
       detail: "Commit message runner configuration is invalid."
     }}
  end

  defp safe_invoke_commit_message_runner(commit_message_runner, args, branch_context)
       when is_function(commit_message_runner, 2) and is_map(args) and is_map(branch_context) do
    try do
      case commit_message_runner.(args, branch_context) do
        :ok ->
          {:ok, %{}}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} when is_binary(result) ->
          {:ok, %{message: result}}

        {:ok, result} ->
          {:error,
           %{
             reason_type: "commit_message_invalid_result",
             detail: "Commit message runner returned an invalid result (#{inspect(result)}).",
             reason: result
           }}

        {:error, reason} ->
          {:error, reason}

        other ->
          {:error,
           %{
             reason_type: "commit_message_invalid_result",
             detail: "Commit message runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "commit_message_runner_crashed",
           detail: "Commit message runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "commit_message_runner_threw",
           detail: "Commit message runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp build_commit_message_contract_check(args, branch_context, commit_message_result)
       when is_map(args) and is_map(branch_context) and is_map(commit_message_result) do
    environment_mode = environment_mode_from_args(args)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    workflow_name =
      branch_derivation
      |> map_get(:workflow_name, "workflow_name")
      |> normalize_optional_string()

    run_id =
      branch_derivation
      |> map_get(:run_id, "run_id")
      |> normalize_optional_string()

    commit_message =
      commit_message_from_sources(
        args,
        commit_message_result,
        workflow_name,
        run_id
      )

    validation =
      validate_commit_message_contract_content(
        commit_message,
        workflow_name,
        run_id
      )

    blocked_actions = commit_message_blocked_actions(validation.status)

    %{
      id: @commit_message_check_id,
      name: @commit_message_check_name,
      status: validation.status,
      contract: %{
        format: "type_summary_body_with_workflow_metadata_trailers",
        required_trailers: ["Generated by JidoCode workflow", "Run ID"]
      },
      message: commit_message,
      commit_type: validation.commit_type,
      summary: validation.summary,
      body: validation.body,
      trailers: validation.trailers,
      validation_errors: validation.errors,
      blocked_actions: blocked_actions,
      blocked_action_details: commit_message_blocked_action_details(validation.errors, blocked_actions),
      detail: commit_message_detail(validation.status, validation.errors),
      remediation: commit_message_remediation(validation.status),
      run_metadata: %{
        workflow_name: workflow_name,
        run_id: run_id,
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: commit_message_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_commit_message_contract_check(_args, branch_context, _commit_message_result) do
    build_commit_message_tooling_failure_check(
      %{},
      branch_context,
      :invalid_commit_message_result
    )
  end

  defp build_commit_message_tooling_failure_check(args, branch_context, reason)
       when is_map(args) and is_map(branch_context) do
    environment_mode = environment_mode_from_args(args)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    detail =
      map_get(
        reason,
        :detail,
        "detail",
        "Commit message generation failed and shipping is blocked by fail-closed policy."
      )

    %{
      id: @commit_message_check_id,
      name: @commit_message_check_name,
      status: "failed",
      contract: %{
        format: "type_summary_body_with_workflow_metadata_trailers",
        required_trailers: ["Generated by JidoCode workflow", "Run ID"]
      },
      message: nil,
      commit_type: nil,
      summary: nil,
      body: nil,
      trailers: %{},
      validation_errors: [
        %{
          reason: "commit_message_generation_failed",
          detail: detail
        }
      ],
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details:
        commit_message_blocked_action_details(
          [%{reason: "commit_message_generation_failed"}],
          @blocked_shipping_actions
        ),
      detail: detail,
      remediation: @commit_message_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: commit_message_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp build_commit_message_tooling_failure_check(_args, branch_context, _reason) do
    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @commit_message_check_id,
      name: @commit_message_check_name,
      status: "failed",
      contract: %{
        format: "type_summary_body_with_workflow_metadata_trailers",
        required_trailers: ["Generated by JidoCode workflow", "Run ID"]
      },
      message: nil,
      commit_type: nil,
      summary: nil,
      body: nil,
      trailers: %{},
      validation_errors: [
        %{
          reason: "commit_message_generation_failed",
          detail: "Commit message generation failed and shipping is blocked by fail-closed policy."
        }
      ],
      blocked_actions: @blocked_shipping_actions,
      blocked_action_details:
        commit_message_blocked_action_details(
          [%{reason: "commit_message_generation_failed"}],
          @blocked_shipping_actions
        ),
      detail: "Commit message generation failed and shipping is blocked by fail-closed policy.",
      remediation: @commit_message_remediation,
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: "cloud"
      },
      step_metadata: commit_message_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp validate_commit_message_contract_content(commit_message, workflow_name, run_id)
       when is_binary(commit_message) do
    normalized_message = normalize_commit_message_text(commit_message)

    case Regex.named_captures(@commit_message_contract_pattern, normalized_message) do
      nil ->
        %{
          status: "failed",
          commit_type: nil,
          summary: nil,
          body: nil,
          trailers: %{},
          errors: [
            %{
              reason: "commit_message_contract_invalid",
              detail:
                "Commit message must follow '<type>: <summary>', include a body, and end with required workflow metadata trailers."
            }
          ]
        }

      captures ->
        commit_type = captures["commit_type"] |> normalize_optional_string()
        summary = captures["summary"] |> normalize_optional_string()
        body = captures["body"] |> normalize_optional_string()
        trailer_workflow_name = captures["workflow_name"] |> normalize_optional_string()
        trailer_run_id = captures["run_id"] |> normalize_optional_string()

        errors =
          []
          |> maybe_append_commit_message_error(is_nil(body), %{
            reason: "commit_message_body_missing",
            detail: "Commit message body must be present."
          })
          |> maybe_append_commit_message_error(
            trailer_workflow_name != workflow_name,
            %{
              reason: "workflow_metadata_mismatch",
              detail: "Commit trailer workflow metadata must match active workflow identifier exactly.",
              expected: workflow_name,
              observed: trailer_workflow_name
            }
          )
          |> maybe_append_commit_message_error(
            trailer_run_id != run_id,
            %{
              reason: "run_id_metadata_mismatch",
              detail: "Commit trailer run metadata must match active run identifier exactly.",
              expected: run_id,
              observed: trailer_run_id
            }
          )

        %{
          status: if(errors == [], do: "passed", else: "failed"),
          commit_type: commit_type,
          summary: summary,
          body: body,
          trailers: %{
            workflow_name: trailer_workflow_name,
            run_id: trailer_run_id
          },
          errors: errors
        }
    end
  end

  defp validate_commit_message_contract_content(_commit_message, _workflow_name, _run_id) do
    %{
      status: "failed",
      commit_type: nil,
      summary: nil,
      body: nil,
      trailers: %{},
      errors: [
        %{
          reason: "commit_message_contract_invalid",
          detail: "Commit message is unavailable and contract validation failed."
        }
      ]
    }
  end

  defp maybe_append_commit_message_error(errors, condition, error)
       when is_list(errors) and is_map(error) do
    if condition do
      errors ++ [error]
    else
      errors
    end
  end

  defp maybe_append_commit_message_error(errors, _condition, _error), do: errors

  defp commit_message_blocked_actions("failed"), do: @blocked_shipping_actions
  defp commit_message_blocked_actions(_status), do: []

  defp commit_message_blocked_action_details(_errors, blocked_actions)
       when is_list(blocked_actions) and blocked_actions == [] do
    []
  end

  defp commit_message_blocked_action_details(errors, blocked_actions)
       when is_list(errors) and is_list(blocked_actions) do
    reason = commit_message_block_reason(errors)

    Enum.map(blocked_actions, fn blocked_action ->
      %{
        action: blocked_action,
        blocked: true,
        reason: reason,
        detail: "Commit message contract blocked #{blocked_action}."
      }
    end)
  end

  defp commit_message_blocked_action_details(_errors, _blocked_actions), do: []

  defp commit_message_block_reason(errors) when is_list(errors) do
    cond do
      Enum.any?(errors, fn error ->
        map_get(error, :reason, "reason") in [
          "workflow_metadata_mismatch",
          "run_id_metadata_mismatch"
        ]
      end) ->
        "commit_metadata_mismatch"

      Enum.any?(errors, fn error ->
        map_get(error, :reason, "reason") == "commit_message_generation_failed"
      end) ->
        "commit_message_generation_failed"

      true ->
        "commit_message_contract_invalid"
    end
  end

  defp commit_message_block_reason(_errors), do: "commit_message_contract_invalid"

  defp commit_message_detail("passed", _errors) do
    "Commit message satisfies required type/summary/body format and workflow metadata trailer contract."
  end

  defp commit_message_detail("failed", errors) when is_list(errors) do
    details =
      errors
      |> Enum.map(&map_get(&1, :detail, "detail"))
      |> Enum.map(&normalize_optional_string/1)
      |> Enum.reject(&is_nil/1)
      |> Enum.join(" ")

    if details == "" do
      "Commit message failed required contract validation."
    else
      "Commit message failed required contract validation: #{details}"
    end
  end

  defp commit_message_detail(_status, _errors),
    do: "Commit message failed required contract validation."

  defp commit_message_remediation("passed"), do: "Commit message contract satisfied."
  defp commit_message_remediation(_status), do: @commit_message_remediation

  defp commit_message_reason_type(%{} = commit_message_check) do
    errors = map_get(commit_message_check, :validation_errors, "validation_errors", [])

    cond do
      Enum.any?(errors, fn error ->
        map_get(error, :reason, "reason") in [
          "workflow_metadata_mismatch",
          "run_id_metadata_mismatch"
        ]
      end) ->
        "commit_metadata_mismatch"

      Enum.any?(errors, fn error ->
        map_get(error, :reason, "reason") == "commit_message_generation_failed"
      end) ->
        "commit_message_generation_failed"

      true ->
        "commit_message_contract_invalid"
    end
  end

  defp commit_message_reason_type(_commit_message_check), do: "commit_message_contract_invalid"

  defp commit_message_step_metadata do
    step_metadata(@commit_message_stage, @commit_message_operation)
  end

  defp commit_message_artifact(%{} = commit_message_check) do
    %{
      message: map_get(commit_message_check, :message, "message"),
      commit_type: map_get(commit_message_check, :commit_type, "commit_type"),
      summary: map_get(commit_message_check, :summary, "summary"),
      body: map_get(commit_message_check, :body, "body"),
      trailers: map_get(commit_message_check, :trailers, "trailers", %{}),
      checked_at: map_get(commit_message_check, :checked_at, "checked_at")
    }
  end

  defp commit_message_artifact(_commit_message_check) do
    %{
      message: nil,
      commit_type: nil,
      summary: nil,
      body: nil,
      trailers: %{},
      checked_at: timestamp_now()
    }
  end

  defp commit_type_from_args(args) when is_map(args) do
    args
    |> map_get(
      :commit_type,
      "commit_type",
      map_get(args, :change_type, "change_type", map_get(args, :type, "type"))
    )
    |> normalize_commit_type()
    |> case do
      nil -> @commit_message_type_fallback
      commit_type -> commit_type
    end
  end

  defp commit_type_from_args(_args), do: @commit_message_type_fallback

  defp normalize_commit_type(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      commit_type ->
        commit_type
        |> String.downcase()
        |> String.replace(~r/[^a-z0-9_-]/, "")
        |> normalize_optional_string()
    end
  end

  defp commit_summary_from_args(args, workflow_name) when is_map(args) do
    args
    |> map_get(
      :commit_summary,
      "commit_summary",
      map_get(
        args,
        :summary,
        "summary",
        map_get(
          args,
          :task_summary,
          "task_summary",
          map_get(args, :change_summary, "change_summary")
        )
      )
    )
    |> normalize_commit_summary()
    |> case do
      nil ->
        workflow_reference = normalize_optional_string(workflow_name) || "workflow"
        "#{@commit_message_summary_fallback} for #{workflow_reference}"

      summary ->
        summary
    end
  end

  defp commit_summary_from_args(_args, workflow_name) do
    workflow_reference = normalize_optional_string(workflow_name) || "workflow"
    "#{@commit_message_summary_fallback} for #{workflow_reference}"
  end

  defp normalize_commit_summary(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      summary ->
        summary
        |> String.replace(~r/\s+/, " ")
        |> String.trim()
        |> normalize_optional_string()
    end
  end

  defp commit_body_from_args(args, workflow_name) when is_map(args) do
    args
    |> map_get(
      :commit_body,
      "commit_body",
      map_get(
        args,
        :body,
        "body",
        map_get(
          args,
          :implementation_summary,
          "implementation_summary",
          map_get(args, :diff_summary, "diff_summary")
        )
      )
    )
    |> normalize_commit_body()
    |> case do
      nil ->
        workflow_reference = normalize_optional_string(workflow_name) || "workflow"
        "#{@commit_message_body_fallback} Generated by #{workflow_reference}."

      body ->
        body
    end
  end

  defp commit_body_from_args(_args, workflow_name) do
    workflow_reference = normalize_optional_string(workflow_name) || "workflow"
    "#{@commit_message_body_fallback} Generated by #{workflow_reference}."
  end

  defp normalize_commit_body(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      body ->
        body
        |> String.trim()
        |> normalize_optional_string()
    end
  end

  defp commit_message_from_sources(args, commit_message_result, workflow_name, run_id)
       when is_map(args) and is_map(commit_message_result) do
    commit_message_result
    |> map_get(
      :message,
      "message",
      map_get(
        commit_message_result,
        :commit_message,
        "commit_message",
        map_get(commit_message_result, :text, "text")
      )
    )
    |> normalize_optional_string()
    |> case do
      nil ->
        compose_commit_message(
          commit_type_from_args(args),
          commit_summary_from_args(args, workflow_name),
          commit_body_from_args(args, workflow_name),
          workflow_name,
          run_id
        )

      commit_message ->
        normalize_commit_message_text(commit_message)
    end
  end

  defp commit_message_from_sources(_args, _commit_message_result, workflow_name, run_id) do
    compose_commit_message(
      @commit_message_type_fallback,
      @commit_message_summary_fallback,
      @commit_message_body_fallback,
      workflow_name,
      run_id
    )
  end

  defp compose_commit_message(commit_type, summary, body, workflow_name, run_id) do
    normalized_type = normalize_commit_type(commit_type) || @commit_message_type_fallback
    normalized_summary = normalize_commit_summary(summary) || @commit_message_summary_fallback
    normalized_body = normalize_commit_body(body) || @commit_message_body_fallback
    normalized_workflow_name = normalize_optional_string(workflow_name) || "workflow"
    normalized_run_id = normalize_optional_string(run_id) || "run"

    [
      "#{normalized_type}: #{normalized_summary}",
      "",
      normalized_body,
      "",
      "Generated by JidoCode workflow: #{normalized_workflow_name}",
      "Run ID: #{normalized_run_id}"
    ]
    |> Enum.join("\n")
    |> normalize_commit_message_text()
  end

  defp normalize_commit_message_text(commit_message) when is_binary(commit_message) do
    commit_message
    |> String.replace("\r\n", "\n")
    |> String.trim_trailing("\n")
  end

  defp normalize_commit_message_text(_commit_message), do: ""

  defp maybe_probe_commit(branch_context, opts) when is_map(branch_context) and is_list(opts) do
    case Keyword.get(opts, :commit_probe) do
      commit_probe when is_function(commit_probe, 1) ->
        commit_probe.(branch_context)
        :ok

      _other ->
        :ok
    end
  rescue
    _exception -> :ok
  end

  defp maybe_probe_commit(_branch_context, _opts), do: :ok

  defp maybe_execute_push(args, branch_context, branch_setup, opts)
       when is_map(args) and is_map(branch_context) and is_list(opts) do
    if push_requested?(args, opts) do
      execute_push_with_auth_retry(args, branch_context, branch_setup, opts)
    else
      {:ok, skipped_push_execution(branch_context)}
    end
  end

  defp maybe_execute_push(_args, branch_context, _branch_setup, _opts)
       when is_map(branch_context),
       do: {:ok, skipped_push_execution(branch_context)}

  defp maybe_execute_push(_args, _branch_context, _branch_setup, _opts),
    do: {:ok, skipped_push_execution(%{})}

  defp push_requested?(args, opts) when is_map(args) and is_list(opts) do
    explicit_push_opt_in? =
      args
      |> map_get(:execute_push, "execute_push", map_get(args, :push_enabled, "push_enabled"))
      |> normalize_optional_boolean()
      |> Kernel.==(true)

    explicit_mode_opt_in? =
      args
      |> map_get(:shipping_mode, "shipping_mode")
      |> normalize_optional_string()
      |> case do
        nil -> false
        mode -> String.downcase(mode) in ["ship", "full", "push", "commit_push_pr"]
      end

    Keyword.has_key?(opts, :push_runner) or explicit_push_opt_in? or explicit_mode_opt_in?
  end

  defp push_requested?(_args, _opts), do: false

  defp execute_push_with_auth_retry(args, branch_context, branch_setup, opts)
       when is_map(args) and is_map(branch_context) and is_list(opts) do
    push_runner = Keyword.get(opts, :push_runner, &__MODULE__.default_push_runner/2)

    github_auth_refresh_runner =
      Keyword.get(
        opts,
        :github_auth_refresh_runner,
        &__MODULE__.default_github_auth_refresh_runner/2
      )

    case perform_push_attempt(push_runner, args, branch_context, 1, false) do
      {:ok, push_result, push_log} ->
        {:ok,
         successful_push_execution(
           branch_context,
           push_result,
           [push_log],
           false,
           nil,
           nil
         )}

      {:error, first_push_failure, first_push_log} ->
        if push_auth_failure?(first_push_failure) do
          {refresh_outcome, refresh_log} =
            perform_github_auth_refresh(
              github_auth_refresh_runner,
              args,
              branch_context
            )

          case perform_push_attempt(push_runner, args, branch_context, 2, true) do
            {:ok, retry_push_result, retry_push_log} ->
              {:ok,
               successful_push_execution(
                 branch_context,
                 retry_push_result,
                 [first_push_log, refresh_log, retry_push_log],
                 true,
                 first_push_failure,
                 refresh_outcome
               )}

            {:error, retry_push_failure, retry_push_log} ->
              {:error,
               push_auth_retry_error(
                 first_push_failure,
                 refresh_outcome,
                 retry_push_failure,
                 branch_context,
                 branch_setup,
                 [first_push_log, refresh_log, retry_push_log]
               )}
          end
        else
          {:error,
           push_error(
             first_push_failure,
             branch_context,
             branch_setup,
             [first_push_log]
           )}
        end
    end
  end

  defp execute_push_with_auth_retry(_args, branch_context, _branch_setup, _opts)
       when is_map(branch_context),
       do: {:ok, skipped_push_execution(branch_context)}

  defp execute_push_with_auth_retry(_args, _branch_context, _branch_setup, _opts),
    do: {:ok, skipped_push_execution(%{})}

  @doc false
  @spec default_push_runner(map(), map()) :: {:ok, map()} | {:error, map()}
  def default_push_runner(args, _branch_context) when is_map(args) do
    case push_signal_from_args(args) do
      {:passed, detail} ->
        {:ok,
         %{
           status: "pushed",
           detail: detail || "Run branch push completed."
         }}

      {:auth_failure, reason} ->
        {:error,
         %{
           reason_type: "push_auth_failed",
           detail: "Run branch push failed due to GitHub authentication error.",
           reason: reason
         }}

      {:failed, reason} ->
        {:error,
         %{
           reason_type: "push_failed",
           detail: "Run branch push failed.",
           reason: reason
         }}
    end
  end

  def default_push_runner(_args, _branch_context) do
    {:error,
     %{
       reason_type: "push_input_invalid",
       detail: "Push inputs are invalid and shipping halted before PR creation.",
       reason: :invalid_push_args
     }}
  end

  @doc false
  @spec default_github_auth_refresh_runner(map(), map()) :: {:ok, map()} | {:error, map()}
  def default_github_auth_refresh_runner(args, _branch_context) when is_map(args) do
    case github_auth_refresh_signal_from_args(args) do
      {:passed, detail} ->
        {:ok,
         %{
           status: "refreshed",
           detail: detail || "GitHub credentials refreshed for push retry."
         }}

      {:failed, reason} ->
        {:error,
         %{
           reason_type: "github_auth_refresh_failed",
           detail: "GitHub credential refresh failed during push auth recovery.",
           reason: reason
         }}
    end
  end

  def default_github_auth_refresh_runner(_args, _branch_context) do
    {:error,
     %{
       reason_type: "github_auth_refresh_input_invalid",
       detail: "GitHub credential refresh input payload is invalid.",
       reason: :invalid_github_auth_refresh_args
     }}
  end

  defp push_signal_from_args(args) when is_map(args) do
    status_hint =
      args
      |> map_get(:push_status, "push_status", map_get(args, :push_result, "push_result"))
      |> normalize_push_status_hint()

    auth_error_reason =
      map_get(
        args,
        :push_auth_error,
        "push_auth_error",
        map_get(args, :github_auth_error, "github_auth_error")
      )

    push_error_reason =
      map_get(
        args,
        :push_error,
        "push_error",
        map_get(args, :push_failure, "push_failure")
      )

    cond do
      status_hint == :auth_failure ->
        {:auth_failure, auth_error_reason || :push_auth_failed}

      not is_nil(auth_error_reason) ->
        {:auth_failure, auth_error_reason}

      status_hint == :failed ->
        {:failed, push_error_reason || :push_failed}

      not is_nil(push_error_reason) ->
        {:failed, push_error_reason}

      true ->
        {:passed, nil}
    end
  end

  defp push_signal_from_args(_args), do: {:failed, :invalid_push_args}

  defp github_auth_refresh_signal_from_args(args) when is_map(args) do
    status_hint =
      args
      |> map_get(
        :github_auth_refresh_status,
        "github_auth_refresh_status",
        map_get(args, :credential_refresh_status, "credential_refresh_status")
      )
      |> normalize_github_auth_refresh_status_hint()

    refresh_error_reason =
      map_get(
        args,
        :github_auth_refresh_error,
        "github_auth_refresh_error",
        map_get(args, :credential_refresh_error, "credential_refresh_error")
      )

    cond do
      status_hint == :failed ->
        {:failed, refresh_error_reason || :github_auth_refresh_failed}

      not is_nil(refresh_error_reason) ->
        {:failed, refresh_error_reason}

      true ->
        {:passed, nil}
    end
  end

  defp github_auth_refresh_signal_from_args(_args),
    do: {:failed, :invalid_github_auth_refresh_args}

  defp normalize_push_status_hint(value) when is_boolean(value) do
    if value, do: :passed, else: :failed
  end

  defp normalize_push_status_hint(%{} = value) do
    value
    |> map_get(:status, "status", map_get(value, :result, "result"))
    |> normalize_push_status_hint()
  end

  defp normalize_push_status_hint(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_status ->
        case String.downcase(normalized_status) do
          "passed" -> :passed
          "pass" -> :passed
          "pushed" -> :passed
          "ok" -> :passed
          "success" -> :passed
          "succeeded" -> :passed
          "auth_failed" -> :auth_failure
          "authentication_failed" -> :auth_failure
          "authorization_failed" -> :auth_failure
          "unauthorized" -> :auth_failure
          "forbidden" -> :auth_failure
          "token_expired" -> :auth_failure
          "failed" -> :failed
          "fail" -> :failed
          "error" -> :failed
          _other -> nil
        end
    end
  end

  defp normalize_github_auth_refresh_status_hint(value) when is_boolean(value) do
    if value, do: :passed, else: :failed
  end

  defp normalize_github_auth_refresh_status_hint(%{} = value) do
    value
    |> map_get(:status, "status", map_get(value, :result, "result"))
    |> normalize_github_auth_refresh_status_hint()
  end

  defp normalize_github_auth_refresh_status_hint(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_status ->
        case String.downcase(normalized_status) do
          "passed" -> :passed
          "pass" -> :passed
          "ok" -> :passed
          "refreshed" -> :passed
          "success" -> :passed
          "succeeded" -> :passed
          "failed" -> :failed
          "fail" -> :failed
          "error" -> :failed
          _other -> nil
        end
    end
  end

  defp perform_push_attempt(push_runner, args, branch_context, attempt, retry?)
       when is_map(args) and is_map(branch_context) do
    push_context =
      branch_context
      |> Map.put(:push_attempt, attempt)
      |> Map.put(:push_retry, retry?)

    case invoke_push_runner(push_runner, args, push_context) do
      {:ok, push_result} ->
        normalized_push_result = normalize_push_result(push_result)

        if push_result_failed?(normalized_push_result) do
          push_failure = normalize_push_failure(normalized_push_result)

          {:error, push_failure, push_attempt_log(attempt, retry?, "failed", push_failure, push_context)}
        else
          {:ok, normalized_push_result,
           push_attempt_log(attempt, retry?, "succeeded", normalized_push_result, push_context)}
        end

      {:error, push_failure_reason} ->
        push_failure = normalize_push_failure(push_failure_reason)

        {:error, push_failure, push_attempt_log(attempt, retry?, "failed", push_failure, push_context)}
    end
  end

  defp perform_push_attempt(_push_runner, _args, branch_context, attempt, retry?)
       when is_map(branch_context) do
    push_failure = normalize_push_failure(:invalid_push_attempt)

    {:error, push_failure, push_attempt_log(attempt, retry?, "failed", push_failure, branch_context)}
  end

  defp perform_github_auth_refresh(github_auth_refresh_runner, args, branch_context)
       when is_map(args) and is_map(branch_context) do
    case invoke_github_auth_refresh_runner(github_auth_refresh_runner, args, branch_context) do
      {:ok, refresh_result} ->
        normalized_refresh_result = normalize_github_auth_refresh_result(refresh_result)

        {{:ok, normalized_refresh_result}, github_auth_refresh_log("succeeded", normalized_refresh_result)}

      {:error, refresh_failure_reason} ->
        refresh_failure = normalize_github_auth_refresh_failure(refresh_failure_reason)
        {{:error, refresh_failure}, github_auth_refresh_log("failed", refresh_failure)}
    end
  end

  defp perform_github_auth_refresh(_github_auth_refresh_runner, _args, _branch_context) do
    refresh_failure = normalize_github_auth_refresh_failure(:invalid_github_auth_refresh_args)
    {{:error, refresh_failure}, github_auth_refresh_log("failed", refresh_failure)}
  end

  defp successful_push_execution(
         branch_context,
         push_result,
         run_logs,
         retry_attempted,
         initial_failure,
         refresh_outcome
       )
       when is_map(branch_context) and is_map(push_result) and is_list(run_logs) do
    branch_name =
      branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    push_artifact =
      %{
        status: push_success_status(retry_attempted),
        attempt_count: if(retry_attempted, do: 2, else: 1),
        retry_attempted: retry_attempted,
        branch_name: branch_name,
        detail:
          map_get(
            push_result,
            :detail,
            "detail",
            if(retry_attempted,
              do: "Run branch push succeeded after one GitHub auth refresh retry.",
              else: "Run branch push completed."
            )
          ),
        side_effect_safety: %{
          branch_setup_repeated: false,
          commit_repeated: false
        },
        pushed_at: timestamp_now()
      }
      |> maybe_put_optional(:remote, map_get(push_result, :remote, "remote"))
      |> maybe_put_optional(
        :command_intent,
        map_get(push_result, :command_intent, "command_intent")
      )

    push_auth_recovery =
      %{
        strategy: @push_auth_retry_strategy,
        retry_limit: @push_auth_retry_limit,
        retry_attempted: retry_attempted,
        auth_refresh_attempted: retry_attempted,
        auth_refresh_status: auth_refresh_status(refresh_outcome)
      }
      |> maybe_put_optional(:initial_reason_type, failure_reason_type(initial_failure))
      |> maybe_put_optional(:initial_reason, failure_reason_message(initial_failure))

    %{
      push: push_artifact,
      push_auth_recovery: push_auth_recovery,
      run_logs: run_logs,
      shipping_flow: %{
        completed_stage: @push_stage,
        next_stage: "create_pr",
        run_logs: run_logs
      }
    }
  end

  defp successful_push_execution(
         branch_context,
         _push_result,
         run_logs,
         _retry_attempted,
         _initial_failure,
         _refresh_outcome
       )
       when is_map(branch_context) and is_list(run_logs),
       do: skipped_push_execution(branch_context, run_logs)

  defp successful_push_execution(
         _branch_context,
         _push_result,
         _run_logs,
         _retry_attempted,
         _initial_failure,
         _refresh_outcome
       ),
       do: skipped_push_execution(%{})

  defp skipped_push_execution(branch_context, run_logs \\ []) when is_map(branch_context) do
    branch_name =
      branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string()

    %{
      push: %{
        status: "not_requested",
        attempt_count: 0,
        retry_attempted: false,
        branch_name: branch_name,
        side_effect_safety: %{
          branch_setup_repeated: false,
          commit_repeated: false
        }
      },
      push_auth_recovery: %{
        strategy: @push_auth_retry_strategy,
        retry_limit: @push_auth_retry_limit,
        retry_attempted: false,
        auth_refresh_attempted: false,
        auth_refresh_status: "not_requested"
      },
      run_logs: run_logs,
      shipping_flow: %{
        completed_stage: "commit_message_contract_check",
        next_stage: "commit_changes",
        run_logs: run_logs
      }
    }
  end

  defp push_auth_retry_error(
         initial_push_failure,
         refresh_outcome,
         retry_push_failure,
         branch_context,
         branch_setup,
         run_logs
       )
       when is_map(branch_context) and is_list(run_logs) do
    preserved_branch_artifact = preserved_branch_artifact(branch_context, branch_setup)

    retry_reason = failure_reason_message(retry_push_failure)

    %{
      error_type: @push_auth_error_type,
      operation: @push_operation,
      reason_type: "push_auth_retry_failed",
      detail:
        format_failure_detail(
          "Run branch push authentication failed after one GitHub credential refresh retry; shipping halted before PR creation.",
          retry_reason
        ),
      remediation: @push_auth_remediation,
      blocked_stage: "create_pr",
      blocked_actions: ["create_pr"],
      halted_before_pr: true,
      branch_name: Map.get(preserved_branch_artifact, :branch_name),
      branch_derivation: Map.get(preserved_branch_artifact, :branch_derivation, %{}),
      preserved_branch_artifact: preserved_branch_artifact,
      push_auth_recovery: %{
        strategy: @push_auth_retry_strategy,
        retry_limit: @push_auth_retry_limit,
        retry_attempted: true,
        auth_refresh_attempted: true,
        auth_refresh_status: auth_refresh_status(refresh_outcome),
        initial_reason_type: failure_reason_type(initial_push_failure),
        initial_reason: failure_reason_message(initial_push_failure),
        retry_reason_type: failure_reason_type(retry_push_failure),
        retry_reason: retry_reason
      },
      run_logs: run_logs,
      timestamp: timestamp_now()
    }
  end

  defp push_auth_retry_error(
         _initial_push_failure,
         _refresh_outcome,
         _retry_push_failure,
         branch_context,
         _branch_setup,
         run_logs
       )
       when is_map(branch_context) and is_list(run_logs) do
    push_error(:push_auth_retry_failed, branch_context, %{}, run_logs)
  end

  defp push_error(push_failure, branch_context, branch_setup, run_logs)
       when is_map(branch_context) and is_list(run_logs) do
    preserved_branch_artifact = preserved_branch_artifact(branch_context, branch_setup)
    reason_type = failure_reason_type(push_failure) || "push_failed"
    reason = failure_reason_message(push_failure)

    %{
      error_type: @push_error_type,
      operation: @push_operation,
      reason_type: reason_type,
      detail:
        format_failure_detail(
          "Run branch push failed and shipping halted before PR creation.",
          reason
        ),
      remediation: "Resolve push failure conditions and retry CommitAndPR shipping.",
      blocked_stage: "create_pr",
      blocked_actions: ["create_pr"],
      halted_before_pr: true,
      branch_name: Map.get(preserved_branch_artifact, :branch_name),
      branch_derivation: Map.get(preserved_branch_artifact, :branch_derivation, %{}),
      preserved_branch_artifact: preserved_branch_artifact,
      push_auth_recovery: %{
        strategy: @push_auth_retry_strategy,
        retry_limit: @push_auth_retry_limit,
        retry_attempted: false,
        auth_refresh_attempted: false,
        auth_refresh_status: "not_attempted"
      },
      run_logs: run_logs,
      timestamp: timestamp_now()
    }
  end

  defp push_error(push_failure, branch_context, _branch_setup, run_logs)
       when is_map(branch_context) and is_list(run_logs),
       do: push_error(push_failure, branch_context, %{}, run_logs)

  defp invoke_push_runner(push_runner, args, branch_context)
       when is_function(push_runner, 2) and is_map(args) and is_map(branch_context) do
    safe_invoke_push_runner(push_runner, args, branch_context)
  end

  defp invoke_push_runner(push_runner, args, branch_context)
       when is_function(push_runner, 1) and is_map(args) and is_map(branch_context) do
    safe_invoke_push_runner(
      fn _args, context -> push_runner.(context) end,
      args,
      branch_context
    )
  end

  defp invoke_push_runner(_push_runner, _args, _branch_context) do
    {:error,
     %{
       reason_type: "push_runner_invalid",
       detail: "Push runner configuration is invalid."
     }}
  end

  defp safe_invoke_push_runner(push_runner, args, branch_context)
       when is_function(push_runner, 2) and is_map(args) and is_map(branch_context) do
    try do
      case push_runner.(args, branch_context) do
        :ok ->
          {:ok, %{status: "pushed"}}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} ->
          {:ok, %{status: "pushed", detail: inspect(result)}}

        {:error, reason} ->
          {:error, reason}

        other ->
          {:error,
           %{
             reason_type: "push_invalid_result",
             detail: "Push runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "push_runner_crashed",
           detail: "Push runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "push_runner_threw",
           detail: "Push runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp invoke_github_auth_refresh_runner(github_auth_refresh_runner, args, branch_context)
       when is_function(github_auth_refresh_runner, 2) and is_map(args) and is_map(branch_context) do
    safe_invoke_github_auth_refresh_runner(github_auth_refresh_runner, args, branch_context)
  end

  defp invoke_github_auth_refresh_runner(github_auth_refresh_runner, args, branch_context)
       when is_function(github_auth_refresh_runner, 1) and is_map(args) and is_map(branch_context) do
    safe_invoke_github_auth_refresh_runner(
      fn _args, context -> github_auth_refresh_runner.(context) end,
      args,
      branch_context
    )
  end

  defp invoke_github_auth_refresh_runner(_github_auth_refresh_runner, _args, _branch_context) do
    {:error,
     %{
       reason_type: "github_auth_refresh_runner_invalid",
       detail: "GitHub auth refresh runner configuration is invalid."
     }}
  end

  defp safe_invoke_github_auth_refresh_runner(github_auth_refresh_runner, args, branch_context)
       when is_function(github_auth_refresh_runner, 2) and is_map(args) and is_map(branch_context) do
    try do
      case github_auth_refresh_runner.(args, branch_context) do
        :ok ->
          {:ok, %{status: "refreshed"}}

        {:ok, result} when is_map(result) ->
          {:ok, result}

        {:ok, result} ->
          {:ok, %{status: "refreshed", detail: inspect(result)}}

        {:error, reason} ->
          {:error, reason}

        other ->
          {:error,
           %{
             reason_type: "github_auth_refresh_invalid_result",
             detail: "GitHub auth refresh runner returned an invalid result (#{inspect(other)}).",
             reason: other
           }}
      end
    rescue
      exception ->
        {:error,
         %{
           reason_type: "github_auth_refresh_runner_crashed",
           detail: "GitHub auth refresh runner crashed (#{Exception.message(exception)}).",
           reason: exception
         }}
    catch
      kind, reason ->
        {:error,
         %{
           reason_type: "github_auth_refresh_runner_threw",
           detail: "GitHub auth refresh runner threw #{inspect({kind, reason})}.",
           reason: {kind, reason}
         }}
    end
  end

  defp normalize_push_result(push_result) when is_map(push_result) do
    status =
      push_result
      |> map_get(:status, "status", "pushed")
      |> normalize_optional_string()
      |> case do
        nil -> "pushed"
        normalized_status -> normalized_status
      end

    push_result
    |> normalize_map()
    |> Map.put(:status, status)
  end

  defp normalize_push_result(push_result) do
    %{
      status: "pushed",
      detail: inspect(push_result)
    }
  end

  defp push_result_failed?(push_result) when is_map(push_result) do
    status =
      push_result
      |> map_get(:status, "status")
      |> normalize_optional_string()
      |> case do
        nil -> "pushed"
        normalized_status -> String.downcase(normalized_status)
      end

    explicit_success =
      push_result
      |> map_get(:success, "success", map_get(push_result, :ok, "ok"))
      |> normalize_optional_boolean()

    cond do
      explicit_success == false ->
        true

      status in [
        "failed",
        "fail",
        "error",
        "auth_failed",
        "authentication_failed",
        "authorization_failed"
      ] ->
        true

      true ->
        false
    end
  end

  defp push_result_failed?(_push_result), do: false

  defp normalize_push_failure(push_failure) when is_map(push_failure) do
    reason =
      map_get(
        push_failure,
        :reason,
        "reason",
        map_get(push_failure, :error, "error", push_failure)
      )

    %{
      reason_type:
        push_failure
        |> map_get(
          :reason_type,
          "reason_type",
          map_get(push_failure, :error_type, "error_type", "push_failed")
        )
        |> normalize_reason_type(),
      detail:
        push_failure
        |> map_get(:detail, "detail", "Run branch push failed."),
      reason: reason
    }
  end

  defp normalize_push_failure(push_failure) do
    %{
      reason_type: "push_failed",
      detail: "Run branch push failed.",
      reason: push_failure
    }
  end

  defp normalize_github_auth_refresh_result(refresh_result) when is_map(refresh_result) do
    status =
      refresh_result
      |> map_get(:status, "status", "refreshed")
      |> normalize_optional_string()
      |> case do
        nil -> "refreshed"
        normalized_status -> normalized_status
      end

    refresh_result
    |> normalize_map()
    |> Map.put(:status, status)
  end

  defp normalize_github_auth_refresh_result(refresh_result) do
    %{
      status: "refreshed",
      detail: inspect(refresh_result)
    }
  end

  defp normalize_github_auth_refresh_failure(refresh_failure) when is_map(refresh_failure) do
    reason =
      map_get(
        refresh_failure,
        :reason,
        "reason",
        map_get(refresh_failure, :error, "error", refresh_failure)
      )

    %{
      reason_type:
        refresh_failure
        |> map_get(
          :reason_type,
          "reason_type",
          map_get(refresh_failure, :error_type, "error_type", "github_auth_refresh_failed")
        )
        |> normalize_reason_type(),
      detail:
        refresh_failure
        |> map_get(
          :detail,
          "detail",
          "GitHub credential refresh failed during push auth recovery."
        ),
      reason: reason
    }
  end

  defp normalize_github_auth_refresh_failure(refresh_failure) do
    %{
      reason_type: "github_auth_refresh_failed",
      detail: "GitHub credential refresh failed during push auth recovery.",
      reason: refresh_failure
    }
  end

  defp push_auth_failure?(push_failure) when is_map(push_failure) do
    push_failure
    |> collision_reason_fragments()
    |> Enum.any?(fn fragment ->
      Enum.any?(@push_auth_reason_fragments, &String.contains?(fragment, &1))
    end)
  end

  defp push_auth_failure?(push_failure) do
    push_failure
    |> normalize_push_failure()
    |> push_auth_failure?()
  end

  defp preserved_branch_artifact(branch_context, branch_setup)
       when is_map(branch_context) do
    %{
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      collision_handling:
        branch_setup
        |> map_get(
          :collision_handling,
          "collision_handling",
          branch_context |> map_get(:collision_handling, "collision_handling")
        )
        |> normalize_map()
    }
  end

  defp preserved_branch_artifact(_branch_context, _branch_setup) do
    %{
      branch_name: nil,
      branch_derivation: %{},
      collision_handling: %{}
    }
  end

  defp push_attempt_log(attempt, retry?, status, payload, push_context)
       when is_integer(attempt) and is_boolean(retry?) and is_map(push_context) do
    %{
      event: "push_attempt",
      attempt: attempt,
      retry: retry?,
      status: status,
      branch_name: push_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      reason_type: failure_reason_type(payload),
      detail: failure_detail(payload),
      timestamp: timestamp_now()
    }
    |> maybe_put_optional(:reason, failure_reason_message(payload))
  end

  defp push_attempt_log(_attempt, _retry?, status, payload, _push_context) do
    %{
      event: "push_attempt",
      status: status,
      reason_type: failure_reason_type(payload),
      detail: failure_detail(payload),
      timestamp: timestamp_now()
    }
    |> maybe_put_optional(:reason, failure_reason_message(payload))
  end

  defp github_auth_refresh_log(status, payload) when is_binary(status) do
    %{
      event: "github_auth_refresh",
      status: status,
      reason_type: failure_reason_type(payload),
      detail: failure_detail(payload),
      timestamp: timestamp_now()
    }
    |> maybe_put_optional(:reason, failure_reason_message(payload))
  end

  defp failure_reason_type(nil), do: nil

  defp failure_reason_type(payload) when is_map(payload) do
    payload
    |> map_get(:reason_type, "reason_type", map_get(payload, :error_type, "error_type"))
    |> normalize_optional_string()
    |> case do
      nil -> nil
      reason_type -> normalize_reason_type(reason_type)
    end
  end

  defp failure_reason_type(_payload), do: nil

  defp failure_detail(payload) when is_map(payload) do
    payload
    |> map_get(:detail, "detail")
    |> normalize_optional_string()
  end

  defp failure_detail(_payload), do: nil

  defp failure_reason_message(payload) when is_map(payload) do
    payload
    |> map_get(:reason, "reason", map_get(payload, :error, "error"))
    |> case do
      nil -> nil
      reason -> format_failure_reason(reason)
    end
    |> normalize_optional_string()
  end

  defp failure_reason_message(payload),
    do: payload |> format_failure_reason() |> normalize_optional_string()

  defp auth_refresh_status(nil), do: "not_attempted"

  defp auth_refresh_status({:ok, refresh_result}) when is_map(refresh_result) do
    refresh_result
    |> map_get(:status, "status", "refreshed")
    |> normalize_optional_string()
    |> case do
      nil -> "refreshed"
      status -> String.downcase(status)
    end
  end

  defp auth_refresh_status({:error, _refresh_failure}), do: "failed"
  defp auth_refresh_status(_refresh_outcome), do: "unknown"

  defp push_success_status(true), do: "pushed_after_auth_refresh_retry"
  defp push_success_status(false), do: "pushed"

  defp maybe_put_optional(map, _key, nil) when is_map(map), do: map
  defp maybe_put_optional(map, _key, "") when is_map(map), do: map
  defp maybe_put_optional(map, key, value) when is_map(map), do: Map.put(map, key, value)
  defp maybe_put_optional(_map, _key, _value), do: %{}

  defp normalize_branch_segment(value, fallback, max_length)
       when is_integer(max_length) and max_length > 0 do
    normalized_segment = normalize_branch_slug(value, fallback)

    if String.length(normalized_segment) <= max_length do
      {normalized_segment, "slug"}
    else
      {truncate_with_hash_suffix(normalized_segment, max_length), "slug_with_hash_suffix"}
    end
  end

  defp normalize_branch_slug(value, fallback) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        fallback

      normalized_value ->
        normalized_value
        |> String.downcase()
        |> String.replace(~r/[^a-z0-9]+/, "-")
        |> String.replace(~r/-+/, "-")
        |> String.trim("-")
        |> case do
          "" -> fallback
          segment -> segment
        end
    end
  end

  defp truncate_with_hash_suffix(segment, max_length)
       when is_binary(segment) and is_integer(max_length) and max_length > @hash_suffix_length + 1 do
    hash_suffix = segment_fingerprint(segment)
    prefix_length = max_length - @hash_suffix_length - 1
    prefix = segment |> String.slice(0, prefix_length) |> String.trim_trailing("-")

    case prefix do
      "" -> String.slice(hash_suffix, 0, max_length)
      normalized_prefix -> "#{normalized_prefix}-#{hash_suffix}"
    end
  end

  defp truncate_with_hash_suffix(segment, max_length)
       when is_binary(segment) and is_integer(max_length) and max_length > 0 do
    segment
    |> segment_fingerprint()
    |> String.slice(0, max_length)
  end

  defp segment_fingerprint(segment) when is_binary(segment) do
    segment
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
    |> String.slice(0, @hash_suffix_length)
  end

  defp build_workspace_policy_check(args, branch_context)
       when is_map(args) and is_map(branch_context) do
    environment_mode = environment_mode_from_args(args)
    observed_state = workspace_state_from_args(args)
    status = workspace_policy_status(observed_state)

    branch_derivation =
      branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map()

    %{
      id: @workspace_policy_check_id,
      name: @workspace_policy_check_name,
      status: status,
      policy_mode: @workspace_policy_mode,
      required_state: @required_workspace_state,
      observed_state: observed_state,
      environment_mode: environment_mode,
      detail: workspace_policy_detail(status, environment_mode, observed_state),
      remediation: workspace_policy_remediation(status),
      run_metadata: %{
        workflow_name:
          branch_derivation
          |> map_get(:workflow_name, "workflow_name")
          |> normalize_optional_string(),
        run_id: branch_derivation |> map_get(:run_id, "run_id") |> normalize_optional_string(),
        branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
        environment_mode: environment_mode
      },
      step_metadata: default_step_metadata(),
      checked_at: timestamp_now()
    }
  end

  defp workspace_policy_status("clean"), do: "passed"
  defp workspace_policy_status(_observed_state), do: "failed"

  defp workspace_policy_detail("passed", environment_mode, "clean") do
    "Workspace is clean and satisfies #{environment_mode} clean-room shipping policy."
  end

  defp workspace_policy_detail("failed", environment_mode, "dirty") do
    "#{String.capitalize(environment_mode)} mode requires a clean workspace before commit, push, and PR."
  end

  defp workspace_policy_detail("failed", environment_mode, _observed_state) do
    "#{String.capitalize(environment_mode)} mode requires a clean workspace, but workspace cleanliness was unknown."
  end

  defp workspace_policy_remediation("passed"),
    do: "Workspace meets clean-room shipping requirements."

  defp workspace_policy_remediation(_status), do: @workspace_policy_remediation

  defp workspace_policy_reason_type(%{observed_state: "dirty"}), do: "workspace_dirty"
  defp workspace_policy_reason_type(%{observed_state: "unknown"}), do: "workspace_state_unknown"
  defp workspace_policy_reason_type(_workspace_policy_check), do: "workspace_policy_failed"

  defp secret_scan_signal_from_args(args) when is_map(args) do
    status_hint =
      args
      |> map_get(
        :secret_scan_status,
        "secret_scan_status",
        map_get(args, :secret_scan_result, "secret_scan_result")
      )
      |> normalize_secret_scan_status_hint()

    findings =
      args
      |> map_get(
        :secret_scan_findings,
        "secret_scan_findings",
        map_get(args, :secret_scan_matches, "secret_scan_matches")
      )
      |> normalize_secret_scan_findings()

    violation_count =
      args
      |> map_get(
        :secret_scan_violation_count,
        "secret_scan_violation_count",
        map_get(args, :secret_scan_violations, "secret_scan_violations")
      )
      |> normalize_secret_scan_violation_count(length(findings))

    secret_scan_passed =
      args
      |> map_get(:secret_scan_passed, "secret_scan_passed")
      |> normalize_optional_boolean()

    tooling_error_reason =
      map_get(
        args,
        :secret_scan_error,
        "secret_scan_error",
        map_get(args, :secret_scan_tooling_error, "secret_scan_tooling_error")
      )

    cond do
      status_hint == :tooling_error ->
        {:tooling_error, tooling_error_reason || :secret_scan_tooling_error}

      not is_nil(tooling_error_reason) ->
        {:tooling_error, tooling_error_reason}

      status_hint == :violation ->
        {:violation, ensure_violation_count(violation_count), findings}

      secret_scan_passed == false ->
        {:violation, ensure_violation_count(violation_count), findings}

      violation_count > 0 ->
        {:violation, violation_count, findings}

      findings != [] ->
        {:violation, ensure_violation_count(violation_count, length(findings)), findings}

      status_hint == :passed ->
        {:passed, 0, []}

      secret_scan_passed == true ->
        {:passed, 0, []}

      true ->
        {:passed, 0, []}
    end
  end

  defp secret_scan_signal_from_args(_args), do: {:tooling_error, :invalid_secret_scan_args}

  defp normalize_secret_scan_status_hint(value) when is_boolean(value) do
    if value, do: :passed, else: :violation
  end

  defp normalize_secret_scan_status_hint(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_status ->
        case String.downcase(normalized_status) do
          "passed" -> :passed
          "pass" -> :passed
          "clean" -> :passed
          "ok" -> :passed
          "success" -> :passed
          "failed" -> :violation
          "fail" -> :violation
          "violation" -> :violation
          "violations" -> :violation
          "violations_detected" -> :violation
          "blocked" -> :violation
          "error" -> :tooling_error
          "tooling_error" -> :tooling_error
          "runner_error" -> :tooling_error
          "scanner_error" -> :tooling_error
          "unavailable" -> :tooling_error
          _other -> nil
        end
    end
  end

  defp normalize_secret_scan_check_status(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_status ->
        case String.downcase(normalized_status) do
          "passed" -> "passed"
          "clean" -> "passed"
          "ok" -> "passed"
          "failed" -> "failed"
          "error" -> "failed"
          "blocked" -> "failed"
          "violations_detected" -> "failed"
          _other -> nil
        end
    end
  end

  defp normalize_secret_scan_outcome(secret_scan_result, status)
       when is_map(secret_scan_result) and is_binary(status) do
    outcome =
      secret_scan_result
      |> map_get(:scan_status, "scan_status")
      |> normalize_optional_string()
      |> case do
        nil ->
          nil

        normalized_scan_status ->
          case String.downcase(normalized_scan_status) do
            "clean" -> @secret_scan_clean_state
            "passed" -> @secret_scan_clean_state
            "ok" -> @secret_scan_clean_state
            "violation" -> @secret_scan_violation_state
            "violations" -> @secret_scan_violation_state
            "violations_detected" -> @secret_scan_violation_state
            "failed" -> @secret_scan_violation_state
            "blocked" -> @secret_scan_violation_state
            "tooling_error" -> @secret_scan_tooling_error_state
            "error" -> @secret_scan_tooling_error_state
            "runner_error" -> @secret_scan_tooling_error_state
            "scanner_error" -> @secret_scan_tooling_error_state
            "unavailable" -> @secret_scan_tooling_error_state
            _other -> nil
          end
      end

    case {status, outcome} do
      {"passed", _any_outcome} ->
        @secret_scan_clean_state

      {"failed", nil} ->
        @secret_scan_violation_state

      {"failed", @secret_scan_clean_state} ->
        @secret_scan_violation_state

      {"failed", normalized_outcome} ->
        normalized_outcome

      _other ->
        @secret_scan_tooling_error_state
    end
  end

  defp normalize_secret_scan_outcome(_secret_scan_result, _status),
    do: @secret_scan_tooling_error_state

  defp normalize_secret_scan_findings(findings) when is_list(findings) do
    findings
    |> Enum.map(&normalize_secret_scan_finding/1)
    |> Enum.reject(fn finding -> finding == %{} end)
  end

  defp normalize_secret_scan_findings(%{} = finding) do
    finding = normalize_secret_scan_finding(finding)

    if finding == %{} do
      []
    else
      [finding]
    end
  end

  defp normalize_secret_scan_findings(findings) when is_binary(findings) do
    case String.trim(findings) do
      "" -> []
      summary -> [%{summary: summary}]
    end
  end

  defp normalize_secret_scan_findings(_findings), do: []

  defp normalize_secret_scan_finding(%{} = finding), do: finding

  defp normalize_secret_scan_finding(finding) when is_binary(finding) do
    case String.trim(finding) do
      "" -> %{}
      summary -> %{summary: summary}
    end
  end

  defp normalize_secret_scan_finding(finding), do: %{summary: inspect(finding)}

  defp normalize_secret_scan_violation_count(value, fallback)

  defp normalize_secret_scan_violation_count(value, _fallback)
       when is_integer(value) and value >= 0,
       do: value

  defp normalize_secret_scan_violation_count(value, _fallback) when is_list(value),
    do: length(value)

  defp normalize_secret_scan_violation_count(true, _fallback), do: 1
  defp normalize_secret_scan_violation_count(false, _fallback), do: 0

  defp normalize_secret_scan_violation_count(value, fallback) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        fallback

      normalized_value ->
        case Integer.parse(normalized_value) do
          {parsed_count, ""} when parsed_count >= 0 -> parsed_count
          _other -> fallback
        end
    end
  end

  defp normalize_violation_count(_violation_count, "passed", _findings), do: 0

  defp normalize_violation_count(violation_count, "failed", findings)
       when is_list(findings) and is_integer(violation_count) do
    ensure_violation_count(violation_count, length(findings))
  end

  defp normalize_violation_count(violation_count, _status, _findings), do: violation_count

  defp ensure_violation_count(violation_count, findings_count \\ 0)

  defp ensure_violation_count(violation_count, _findings_count)
       when is_integer(violation_count) and violation_count > 0,
       do: violation_count

  defp ensure_violation_count(_violation_count, findings_count)
       when is_integer(findings_count) and findings_count > 0,
       do: findings_count

  defp ensure_violation_count(_violation_count, _findings_count), do: 1

  defp secret_scan_blocked_actions("failed"), do: @blocked_shipping_actions
  defp secret_scan_blocked_actions(_status), do: []

  defp secret_scan_blocked_action_details(_scan_status, blocked_actions)
       when is_list(blocked_actions) and blocked_actions == [] do
    []
  end

  defp secret_scan_blocked_action_details(scan_status, blocked_actions)
       when is_list(blocked_actions) do
    Enum.map(blocked_actions, fn blocked_action ->
      %{
        action: blocked_action,
        blocked: true,
        reason: secret_scan_block_reason(scan_status),
        detail: "Secret scan policy blocked #{blocked_action}."
      }
    end)
  end

  defp secret_scan_blocked_action_details(_scan_status, _blocked_actions), do: []

  defp secret_scan_block_reason(@secret_scan_tooling_error_state), do: "secret_scan_tooling_error"
  defp secret_scan_block_reason(@secret_scan_violation_state), do: "secret_scan_violation"
  defp secret_scan_block_reason(_scan_status), do: "policy_violation"

  defp secret_scan_policy_detail("passed", @secret_scan_clean_state, _violation_count) do
    "Secret scan passed with no detected plaintext secrets."
  end

  defp secret_scan_policy_detail("failed", @secret_scan_violation_state, violation_count) do
    "Secret scan detected #{violation_count} potential secret finding(s); commit, push, and PR creation are blocked."
  end

  defp secret_scan_policy_detail("failed", @secret_scan_tooling_error_state, _violation_count) do
    "Secret scan tooling failed and shipping is blocked by fail-closed policy."
  end

  defp secret_scan_policy_detail(_status, _scan_status, _violation_count) do
    "Secret scan policy blocked shipping."
  end

  defp secret_scan_policy_remediation("passed", @secret_scan_clean_state),
    do: "Secret scan policy satisfied."

  defp secret_scan_policy_remediation("failed", @secret_scan_violation_state) do
    "Remove detected secrets from the workspace and retry CommitAndPR shipping."
  end

  defp secret_scan_policy_remediation("failed", @secret_scan_tooling_error_state) do
    "Restore secret-scan tooling availability and retry CommitAndPR shipping."
  end

  defp secret_scan_policy_remediation(_status, _scan_status), do: @secret_scan_policy_remediation

  defp secret_scan_step_metadata do
    step_metadata(@secret_scan_policy_stage, @secret_scan_policy_operation)
  end

  defp diff_size_reason_type(%{decision: "approval_override_required"}),
    do: "approval_override_required"

  defp diff_size_reason_type(%{decision: "blocked"}), do: "diff_size_threshold_exceeded"
  defp diff_size_reason_type(_diff_size_policy_check), do: "policy_violation"

  defp diff_size_decision(false, _on_exceed), do: "within_threshold"
  defp diff_size_decision(true, "require_approval_override"), do: "approval_override_required"
  defp diff_size_decision(true, _on_exceed), do: "blocked"

  defp diff_size_blocked_actions("failed"), do: @blocked_shipping_actions
  defp diff_size_blocked_actions(_status), do: []

  defp diff_size_blocked_action_details(_decision, blocked_actions)
       when is_list(blocked_actions) and blocked_actions == [] do
    []
  end

  defp diff_size_blocked_action_details(decision, blocked_actions)
       when is_list(blocked_actions) do
    Enum.map(blocked_actions, fn blocked_action ->
      %{
        action: blocked_action,
        blocked: true,
        reason: diff_size_block_reason(decision),
        detail: "Diff size threshold policy blocked #{blocked_action}."
      }
    end)
  end

  defp diff_size_blocked_action_details(_decision, _blocked_actions), do: []

  defp diff_size_block_reason("approval_override_required"), do: "approval_override_required"
  defp diff_size_block_reason("blocked"), do: "diff_size_threshold_exceeded"
  defp diff_size_block_reason("tooling_error"), do: "diff_size_tooling_error"
  defp diff_size_block_reason(_decision), do: "policy_violation"

  defp diff_size_policy_detail(
         "passed",
         "within_threshold",
         total_lines_changed,
         max_changed_lines,
         _source
       ) do
    "Diff size #{total_lines_changed} changed line(s) is within configured threshold #{max_changed_lines}."
  end

  defp diff_size_policy_detail(
         "failed",
         "approval_override_required",
         total_lines_changed,
         max_changed_lines,
         source
       ) do
    "Diff size #{total_lines_changed} changed line(s) exceeded #{diff_threshold_source_label(source)} threshold #{max_changed_lines}; explicit approval override is required before shipping."
  end

  defp diff_size_policy_detail(
         "failed",
         "blocked",
         total_lines_changed,
         max_changed_lines,
         source
       ) do
    "Diff size #{total_lines_changed} changed line(s) exceeded #{diff_threshold_source_label(source)} threshold #{max_changed_lines}; shipping is blocked by policy."
  end

  defp diff_size_policy_detail(
         _status,
         _decision,
         total_lines_changed,
         max_changed_lines,
         source
       ) do
    "Diff size #{total_lines_changed} changed line(s) exceeded #{diff_threshold_source_label(source)} threshold #{max_changed_lines}; shipping is blocked by policy."
  end

  defp diff_size_policy_remediation("passed", "within_threshold"),
    do: "Diff size policy satisfied."

  defp diff_size_policy_remediation("failed", "approval_override_required") do
    "Request explicit approval override for the oversized diff before retrying CommitAndPR shipping."
  end

  defp diff_size_policy_remediation(_status, _decision), do: @diff_size_policy_remediation

  defp diff_threshold_source_label("workflow_policy"), do: "workflow"
  defp diff_threshold_source_label("project_policy"), do: "project"
  defp diff_threshold_source_label("shipping_policy"), do: "shipping"
  defp diff_threshold_source_label("runner_policy"), do: "runner"
  defp diff_threshold_source_label("args"), do: "input"
  defp diff_threshold_source_label(_source), do: "configured"

  defp diff_size_step_metadata do
    step_metadata(@diff_size_policy_stage, @diff_size_policy_operation)
  end

  defp diff_threshold_policy(args, diff_size_result)
       when is_map(args) and is_map(diff_size_result) do
    [
      runner_threshold_candidate(diff_size_result),
      {"workflow_policy", policy_diff_threshold_candidate(map_get(args, :workflow_policy, "workflow_policy"))},
      {"project_policy", policy_diff_threshold_candidate(map_get(args, :project_policy, "project_policy"))},
      {"shipping_policy", policy_diff_threshold_candidate(map_get(args, :shipping_policy, "shipping_policy"))},
      {"args",
       map_get(
         args,
         :diff_size_threshold,
         "diff_size_threshold",
         map_get(args, :max_diff_lines, "max_diff_lines")
       )}
    ]
    |> Enum.find_value(&normalize_diff_threshold_candidate/1)
    |> case do
      nil -> default_diff_threshold_policy()
      threshold_policy -> threshold_policy
    end
  end

  defp diff_threshold_policy(_args, _diff_size_result), do: default_diff_threshold_policy()

  defp runner_threshold_candidate(diff_size_result) when is_map(diff_size_result) do
    {"runner_policy",
     map_get(
       diff_size_result,
       :threshold_policy,
       "threshold_policy",
       map_get(diff_size_result, :diff_size_threshold, "diff_size_threshold")
     )}
  end

  defp runner_threshold_candidate(_diff_size_result), do: {"runner_policy", nil}

  defp policy_diff_threshold_candidate(policy_map) when is_map(policy_map) do
    map_get(
      policy_map,
      :diff_size_threshold,
      "diff_size_threshold",
      map_get(
        policy_map,
        :diff_size,
        "diff_size",
        map_get(policy_map, :max_diff_lines, "max_diff_lines")
      )
    )
  end

  defp policy_diff_threshold_candidate(_policy_map), do: nil

  defp normalize_diff_threshold_candidate({source, candidate}) do
    max_changed_lines = diff_threshold_max_lines(candidate)

    if is_integer(max_changed_lines) and max_changed_lines > 0 do
      %{
        source: source,
        max_changed_lines: max_changed_lines,
        on_exceed: diff_threshold_exceed_policy(candidate)
      }
    else
      nil
    end
  end

  defp normalize_diff_threshold_candidate(_candidate), do: nil

  defp diff_threshold_max_lines(candidate) when is_integer(candidate), do: candidate

  defp diff_threshold_max_lines(candidate) when is_map(candidate) do
    candidate
    |> map_get(
      :max_changed_lines,
      "max_changed_lines",
      map_get(
        candidate,
        :max_lines,
        "max_lines",
        map_get(
          candidate,
          :threshold,
          "threshold",
          map_get(
            candidate,
            :line_limit,
            "line_limit",
            map_get(candidate, :limit, "limit")
          )
        )
      )
    )
    |> normalize_optional_non_negative_integer()
  end

  defp diff_threshold_max_lines(candidate) do
    candidate
    |> normalize_optional_non_negative_integer()
  end

  defp diff_threshold_exceed_policy(%{} = candidate) do
    candidate
    |> map_get(
      :on_exceed,
      "on_exceed",
      map_get(
        candidate,
        :exceed_action,
        "exceed_action",
        map_get(
          candidate,
          :decision,
          "decision",
          map_get(candidate, :outcome, "outcome", "block")
        )
      )
    )
    |> normalize_diff_threshold_exceed_policy()
  end

  defp diff_threshold_exceed_policy(_candidate), do: "block"

  defp normalize_diff_threshold_exceed_policy(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        "block"

      normalized_value ->
        case String.downcase(normalized_value) do
          "block" -> "block"
          "blocked" -> "block"
          "deny" -> "block"
          "escalate" -> "require_approval_override"
          "approval_override" -> "require_approval_override"
          "require_approval_override" -> "require_approval_override"
          "manual_override" -> "require_approval_override"
          _other -> "block"
        end
    end
  end

  defp default_diff_threshold_policy do
    %{
      source: "default",
      max_changed_lines: @default_diff_max_changed_lines,
      on_exceed: "block"
    }
  end

  defp diff_metrics_from_sources(args, diff_size_result)
       when is_map(args) and is_map(diff_size_result) do
    result_metrics =
      diff_size_result
      |> map_get(:metrics, "metrics")
      |> normalize_map()

    args_metrics =
      args
      |> map_get(:diff_metrics, "diff_metrics")
      |> normalize_map()

    files_changed =
      first_non_negative_integer(
        [
          map_get(result_metrics, :files_changed, "files_changed"),
          map_get(result_metrics, :changed_files_count, "changed_files_count"),
          map_get(diff_size_result, :files_changed, "files_changed"),
          map_get(diff_size_result, :changed_files_count, "changed_files_count"),
          map_get(args_metrics, :files_changed, "files_changed"),
          map_get(args_metrics, :changed_files_count, "changed_files_count"),
          map_get(args, :files_changed, "files_changed"),
          map_get(args, :changed_files_count, "changed_files_count"),
          diff_files_count(diff_size_result, args)
        ],
        0
      )

    lines_added =
      first_non_negative_integer(
        [
          map_get(result_metrics, :lines_added, "lines_added"),
          map_get(result_metrics, :additions, "additions"),
          map_get(diff_size_result, :lines_added, "lines_added"),
          map_get(diff_size_result, :additions, "additions"),
          map_get(args_metrics, :lines_added, "lines_added"),
          map_get(args_metrics, :additions, "additions"),
          map_get(args, :lines_added, "lines_added"),
          map_get(args, :additions, "additions"),
          map_get(args, :diff_lines_added, "diff_lines_added")
        ],
        0
      )

    lines_deleted =
      first_non_negative_integer(
        [
          map_get(result_metrics, :lines_deleted, "lines_deleted"),
          map_get(result_metrics, :deletions, "deletions"),
          map_get(diff_size_result, :lines_deleted, "lines_deleted"),
          map_get(diff_size_result, :deletions, "deletions"),
          map_get(args_metrics, :lines_deleted, "lines_deleted"),
          map_get(args_metrics, :deletions, "deletions"),
          map_get(args, :lines_deleted, "lines_deleted"),
          map_get(args, :deletions, "deletions"),
          map_get(args, :diff_lines_deleted, "diff_lines_deleted")
        ],
        0
      )

    explicit_total_lines_changed =
      first_optional_non_negative_integer([
        map_get(result_metrics, :total_lines_changed, "total_lines_changed"),
        map_get(result_metrics, :diff_size, "diff_size"),
        map_get(result_metrics, :diff_line_count, "diff_line_count"),
        map_get(diff_size_result, :total_lines_changed, "total_lines_changed"),
        map_get(diff_size_result, :diff_size, "diff_size"),
        map_get(diff_size_result, :diff_line_count, "diff_line_count"),
        map_get(args_metrics, :total_lines_changed, "total_lines_changed"),
        map_get(args_metrics, :diff_size, "diff_size"),
        map_get(args_metrics, :diff_line_count, "diff_line_count"),
        map_get(args, :total_lines_changed, "total_lines_changed"),
        map_get(args, :diff_size, "diff_size"),
        map_get(args, :diff_line_count, "diff_line_count")
      ])

    derived_total_lines_changed = lines_added + lines_deleted

    total_lines_changed =
      case explicit_total_lines_changed do
        nil -> derived_total_lines_changed
        parsed_total_lines_changed -> max(parsed_total_lines_changed, derived_total_lines_changed)
      end

    %{
      files_changed: files_changed,
      lines_added: lines_added,
      lines_deleted: lines_deleted,
      total_lines_changed: total_lines_changed
    }
  end

  defp diff_metrics_from_sources(_args, _diff_size_result) do
    %{files_changed: 0, lines_added: 0, lines_deleted: 0, total_lines_changed: 0}
  end

  defp diff_files_count(diff_size_result, args) do
    diff_size_result
    |> map_get(
      :diff_files,
      "diff_files",
      map_get(
        diff_size_result,
        :changed_files,
        "changed_files",
        map_get(
          args,
          :diff_files,
          "diff_files",
          map_get(args, :changed_files, "changed_files")
        )
      )
    )
    |> normalize_optional_non_negative_integer()
  end

  defp first_non_negative_integer(candidates, fallback) when is_list(candidates) do
    case first_optional_non_negative_integer(candidates) do
      nil -> fallback
      value -> value
    end
  end

  defp first_non_negative_integer(_candidates, fallback), do: fallback

  defp first_optional_non_negative_integer(candidates) when is_list(candidates) do
    Enum.find_value(candidates, &normalize_optional_non_negative_integer/1)
  end

  defp first_optional_non_negative_integer(_candidates), do: nil

  defp normalize_optional_non_negative_integer(value)
       when is_integer(value) and value >= 0,
       do: value

  defp normalize_optional_non_negative_integer(value) when is_integer(value), do: nil

  defp normalize_optional_non_negative_integer(value) when is_float(value) and value >= 0,
    do: trunc(value)

  defp normalize_optional_non_negative_integer(value) when is_float(value), do: nil
  defp normalize_optional_non_negative_integer(true), do: 1
  defp normalize_optional_non_negative_integer(false), do: 0

  defp normalize_optional_non_negative_integer(value) when is_list(value),
    do: length(value)

  defp normalize_optional_non_negative_integer(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_value ->
        case Integer.parse(normalized_value) do
          {parsed_value, ""} when parsed_value >= 0 -> parsed_value
          _other -> nil
        end
    end
  end

  defp binary_file_reason_type(%{decision: "approval_override_required"}),
    do: "approval_override_required"

  defp binary_file_reason_type(%{decision: "blocked"}), do: "binary_file_policy_blocked"
  defp binary_file_reason_type(_binary_file_policy_check), do: "policy_violation"

  defp binary_file_decision(0, _on_detect), do: "no_binary_changes"

  defp binary_file_decision(binary_file_count, "require_approval_override")
       when is_integer(binary_file_count) and binary_file_count > 0,
       do: "approval_override_required"

  defp binary_file_decision(binary_file_count, "allow")
       when is_integer(binary_file_count) and binary_file_count > 0,
       do: "allowed_with_binary_changes"

  defp binary_file_decision(binary_file_count, _on_detect)
       when is_integer(binary_file_count) and binary_file_count > 0,
       do: "blocked"

  defp binary_file_decision(_binary_file_count, _on_detect), do: "blocked"

  defp binary_file_status(0, _decision), do: "passed"

  defp binary_file_status(binary_file_count, "allowed_with_binary_changes")
       when is_integer(binary_file_count) and binary_file_count > 0,
       do: "passed"

  defp binary_file_status(_binary_file_count, _decision), do: "failed"

  defp binary_file_blocked_actions("failed"), do: @blocked_shipping_actions
  defp binary_file_blocked_actions(_status), do: []

  defp binary_file_blocked_action_details(_decision, blocked_actions)
       when is_list(blocked_actions) and blocked_actions == [] do
    []
  end

  defp binary_file_blocked_action_details(decision, blocked_actions)
       when is_list(blocked_actions) do
    Enum.map(blocked_actions, fn blocked_action ->
      %{
        action: blocked_action,
        blocked: true,
        reason: binary_file_block_reason(decision),
        detail: "Binary file policy blocked #{blocked_action}."
      }
    end)
  end

  defp binary_file_blocked_action_details(_decision, _blocked_actions), do: []

  defp binary_file_block_reason("approval_override_required"), do: "approval_override_required"
  defp binary_file_block_reason("blocked"), do: "binary_file_policy_blocked"
  defp binary_file_block_reason("tooling_error"), do: "binary_file_policy_tooling_error"
  defp binary_file_block_reason(_decision), do: "policy_violation"

  defp binary_file_policy_detail("passed", "no_binary_changes", _binary_file_count, _source) do
    "No binary file additions or modifications were detected in staged changes."
  end

  defp binary_file_policy_detail(
         "passed",
         "allowed_with_binary_changes",
         binary_file_count,
         source
       ) do
    "Binary file policy allows #{binary_file_count} binary file change(s) from #{binary_policy_source_label(source)} policy scope."
  end

  defp binary_file_policy_detail(
         "failed",
         "approval_override_required",
         binary_file_count,
         source
       ) do
    "Binary file policy detected #{binary_file_count} binary file change(s) from #{binary_policy_source_label(source)} policy scope; explicit approval override is required before shipping."
  end

  defp binary_file_policy_detail("failed", "blocked", binary_file_count, source) do
    "Binary file policy detected #{binary_file_count} binary file change(s) from #{binary_policy_source_label(source)} policy scope and blocked shipping."
  end

  defp binary_file_policy_detail(_status, _decision, binary_file_count, source) do
    "Binary file policy detected #{binary_file_count} binary file change(s) from #{binary_policy_source_label(source)} policy scope and blocked shipping."
  end

  defp binary_file_policy_remediation("passed", "no_binary_changes"),
    do: "Binary file policy satisfied."

  defp binary_file_policy_remediation("passed", "allowed_with_binary_changes"),
    do: "Binary file policy override allows shipping to continue."

  defp binary_file_policy_remediation("failed", "approval_override_required") do
    "Request explicit approval override for binary artifact changes before retrying CommitAndPR shipping."
  end

  defp binary_file_policy_remediation(_status, _decision), do: @binary_file_policy_remediation

  defp binary_policy_source_label("workflow_policy"), do: "workflow"
  defp binary_policy_source_label("project_policy"), do: "project"
  defp binary_policy_source_label("shipping_policy"), do: "shipping"
  defp binary_policy_source_label("runner_policy"), do: "runner"
  defp binary_policy_source_label("args"), do: "input"
  defp binary_policy_source_label(_source), do: "configured"

  defp binary_file_step_metadata do
    step_metadata(@binary_file_policy_stage, @binary_file_policy_operation)
  end

  defp binary_file_policy(args, binary_file_result)
       when is_map(args) and is_map(binary_file_result) do
    [
      runner_binary_policy_candidate(binary_file_result),
      {"workflow_policy", policy_binary_file_candidate(map_get(args, :workflow_policy, "workflow_policy"))},
      {"project_policy", policy_binary_file_candidate(map_get(args, :project_policy, "project_policy"))},
      {"shipping_policy", policy_binary_file_candidate(map_get(args, :shipping_policy, "shipping_policy"))},
      {"args",
       map_get(
         args,
         :binary_file_policy,
         "binary_file_policy",
         map_get(
           args,
           :binary_policy,
           "binary_policy",
           map_get(args, :on_binary_detect, "on_binary_detect")
         )
       )}
    ]
    |> Enum.find_value(&normalize_binary_policy_candidate/1)
    |> case do
      nil -> default_binary_file_policy()
      binary_policy -> binary_policy
    end
  end

  defp binary_file_policy(_args, _binary_file_result), do: default_binary_file_policy()

  defp runner_binary_policy_candidate(binary_file_result) when is_map(binary_file_result) do
    {"runner_policy",
     map_get(
       binary_file_result,
       :binary_policy,
       "binary_policy",
       map_get(
         binary_file_result,
         :binary_file_policy,
         "binary_file_policy",
         map_get(binary_file_result, :policy, "policy")
       )
     )}
  end

  defp runner_binary_policy_candidate(_binary_file_result), do: {"runner_policy", nil}

  defp policy_binary_file_candidate(policy_map) when is_map(policy_map) do
    map_get(
      policy_map,
      :binary_file_policy,
      "binary_file_policy",
      map_get(
        policy_map,
        :binary_policy,
        "binary_policy",
        map_get(policy_map, :binary_files, "binary_files")
      )
    )
  end

  defp policy_binary_file_candidate(_policy_map), do: nil

  defp normalize_binary_policy_candidate({source, candidate}) do
    candidate
    |> binary_policy_on_detect()
    |> case do
      nil ->
        nil

      on_detect ->
        %{
          source: source,
          on_detect: on_detect
        }
    end
  end

  defp normalize_binary_policy_candidate(_candidate), do: nil

  defp binary_policy_on_detect(%{} = candidate) do
    candidate
    |> map_get(
      :on_detect,
      "on_detect",
      map_get(
        candidate,
        :on_binary_detect,
        "on_binary_detect",
        map_get(
          candidate,
          :on_binary_change,
          "on_binary_change",
          map_get(candidate, :decision, "decision", map_get(candidate, :outcome, "outcome"))
        )
      )
    )
    |> normalize_binary_policy_outcome()
  end

  defp binary_policy_on_detect(candidate), do: normalize_binary_policy_outcome(candidate)

  defp normalize_binary_policy_outcome(true), do: @default_binary_policy_on_detect
  defp normalize_binary_policy_outcome(false), do: "allow"

  defp normalize_binary_policy_outcome(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_value ->
        case String.downcase(normalized_value) do
          "block" -> "block"
          "blocked" -> "block"
          "deny" -> "block"
          "disallow" -> "block"
          "escalate" -> "require_approval_override"
          "approval_override" -> "require_approval_override"
          "require_approval_override" -> "require_approval_override"
          "manual_override" -> "require_approval_override"
          "allow" -> "allow"
          "allowed" -> "allow"
          "warn" -> "allow"
          "continue" -> "allow"
          "permit" -> "allow"
          _other -> "block"
        end
    end
  end

  defp default_binary_file_policy do
    %{
      source: "default",
      on_detect: @default_binary_policy_on_detect
    }
  end

  defp binary_detection_from_sources(args, binary_file_result)
       when is_map(args) and is_map(binary_file_result) do
    staged_files = staged_files_from_sources(args, binary_file_result)

    explicit_binary_files =
      explicit_binary_files_from_sources(args, binary_file_result)

    staged_binary_files =
      staged_files
      |> Enum.filter(&binary_file_change_entry?/1)
      |> Enum.filter(&binary_file_change_relevant?/1)

    binary_files =
      (explicit_binary_files ++ staged_binary_files)
      |> dedupe_binary_file_entries()

    %{
      staged_files: staged_files,
      staged_file_count: length(staged_files),
      binary_files: binary_files,
      binary_file_count: length(binary_files),
      binary_detected: binary_files != [],
      detection_source: binary_detection_source(explicit_binary_files, staged_files)
    }
  end

  defp binary_detection_from_sources(_args, _binary_file_result) do
    %{
      staged_files: [],
      staged_file_count: 0,
      binary_files: [],
      binary_file_count: 0,
      binary_detected: false,
      detection_source: "none"
    }
  end

  defp staged_files_from_sources(args, binary_file_result)
       when is_map(args) and is_map(binary_file_result) do
    binary_file_result
    |> map_get(
      :staged_files,
      "staged_files",
      map_get(
        binary_file_result,
        :staged_changes,
        "staged_changes",
        map_get(
          binary_file_result,
          :changed_files,
          "changed_files",
          map_get(
            binary_file_result,
            :files,
            "files",
            map_get(
              args,
              :staged_files,
              "staged_files",
              map_get(
                args,
                :staged_changes,
                "staged_changes",
                map_get(args, :changed_files, "changed_files", map_get(args, :files, "files"))
              )
            )
          )
        )
      )
    )
    |> normalize_binary_file_entries("staged_changes", false)
  end

  defp staged_files_from_sources(_args, _binary_file_result), do: []

  defp explicit_binary_files_from_sources(args, binary_file_result)
       when is_map(args) and is_map(binary_file_result) do
    binary_file_result
    |> map_get(
      :binary_files,
      "binary_files",
      map_get(
        binary_file_result,
        :binary_file_changes,
        "binary_file_changes",
        map_get(
          binary_file_result,
          :binary_paths,
          "binary_paths",
          map_get(
            binary_file_result,
            :staged_binary_files,
            "staged_binary_files",
            map_get(
              args,
              :binary_files,
              "binary_files",
              map_get(
                args,
                :binary_file_changes,
                "binary_file_changes",
                map_get(
                  args,
                  :binary_paths,
                  "binary_paths",
                  map_get(args, :staged_binary_files, "staged_binary_files")
                )
              )
            )
          )
        )
      )
    )
    |> normalize_binary_file_entries("explicit_binary_files", true)
    |> Enum.filter(&binary_file_change_relevant?/1)
  end

  defp explicit_binary_files_from_sources(_args, _binary_file_result), do: []

  defp normalize_binary_file_entries(entries, source, force_binary) when is_list(entries) do
    entries
    |> Enum.map(&normalize_binary_file_entry(&1, source, force_binary))
    |> Enum.reject(fn normalized_entry -> normalized_entry == %{} end)
  end

  defp normalize_binary_file_entries(entry, source, force_binary) do
    normalized_entry = normalize_binary_file_entry(entry, source, force_binary)

    if normalized_entry == %{} do
      []
    else
      [normalized_entry]
    end
  end

  defp normalize_binary_file_entry(%{} = entry, source, force_binary) do
    path =
      entry
      |> map_get(:path, "path", map_get(entry, :file, "file", map_get(entry, :name, "name")))
      |> normalize_optional_string()

    change_type =
      entry
      |> map_get(
        :change_type,
        "change_type",
        map_get(
          entry,
          :status,
          "status",
          map_get(entry, :action, "action", map_get(entry, :mode, "mode"))
        )
      )
      |> normalize_binary_change_type()
      |> case do
        nil when force_binary -> "modified"
        nil -> "unknown"
        normalized_change_type -> normalized_change_type
      end

    binary =
      if force_binary do
        true
      else
        entry
        |> map_get(
          :binary,
          "binary",
          map_get(
            entry,
            :is_binary,
            "is_binary",
            map_get(entry, :binary_file, "binary_file")
          )
        )
        |> normalize_optional_boolean()
        |> case do
          nil -> binary_path_extension?(path)
          binary_flag -> binary_flag
        end
      end

    if is_nil(path) do
      %{}
    else
      %{
        path: path,
        change_type: change_type,
        binary: binary,
        source: source
      }
    end
  end

  defp normalize_binary_file_entry(entry, source, force_binary) when is_binary(entry) do
    path = normalize_optional_string(entry)

    if is_nil(path) do
      %{}
    else
      %{
        path: path,
        change_type: "modified",
        binary: force_binary || binary_path_extension?(path),
        source: source
      }
    end
  end

  defp normalize_binary_file_entry(_entry, _source, _force_binary), do: %{}

  defp binary_file_change_entry?(%{} = entry) do
    binary =
      entry
      |> map_get(:binary, "binary")
      |> normalize_optional_boolean()
      |> case do
        nil -> binary_path_extension?(map_get(entry, :path, "path"))
        binary_flag -> binary_flag
      end

    binary == true
  end

  defp binary_file_change_entry?(_entry), do: false

  defp binary_file_change_relevant?(%{} = entry) do
    entry
    |> map_get(:change_type, "change_type")
    |> normalize_binary_change_type()
    |> case do
      "deleted" -> false
      _other -> true
    end
  end

  defp binary_file_change_relevant?(_entry), do: false

  defp normalize_binary_change_type(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_value ->
        case String.downcase(normalized_value) do
          "a" -> "added"
          "add" -> "added"
          "added" -> "added"
          "new" -> "added"
          "m" -> "modified"
          "mod" -> "modified"
          "modify" -> "modified"
          "modified" -> "modified"
          "changed" -> "modified"
          "update" -> "modified"
          "updated" -> "modified"
          "r" -> "renamed"
          "rename" -> "renamed"
          "renamed" -> "renamed"
          "c" -> "copied"
          "copy" -> "copied"
          "copied" -> "copied"
          "d" -> "deleted"
          "delete" -> "deleted"
          "deleted" -> "deleted"
          "removed" -> "deleted"
          _other -> "unknown"
        end
    end
  end

  defp binary_path_extension?(path) do
    path
    |> normalize_optional_string()
    |> case do
      nil ->
        false

      normalized_path ->
        normalized_path
        |> Path.extname()
        |> String.downcase()
        |> then(&(&1 in @binary_file_extensions))
    end
  end

  defp dedupe_binary_file_entries(entries) when is_list(entries) do
    entries
    |> Enum.reduce({MapSet.new(), []}, fn entry, {seen, acc} ->
      entry_path = entry |> map_get(:path, "path") |> normalize_optional_string()
      change_type = entry |> map_get(:change_type, "change_type", "unknown")
      key = {entry_path, change_type}

      if is_nil(entry_path) or MapSet.member?(seen, key) do
        {seen, acc}
      else
        {MapSet.put(seen, key), [entry | acc]}
      end
    end)
    |> then(fn {_seen, deduped_entries} -> Enum.reverse(deduped_entries) end)
  end

  defp dedupe_binary_file_entries(_entries), do: []

  defp binary_detection_source(explicit_binary_files, _staged_files)
       when is_list(explicit_binary_files) and explicit_binary_files != [] do
    "explicit_binary_files"
  end

  defp binary_detection_source(_explicit_binary_files, staged_files)
       when is_list(staged_files) and staged_files != [] do
    "staged_changes"
  end

  defp binary_detection_source(_explicit_binary_files, _staged_files), do: "none"

  defp environment_mode_from_args(args) when is_map(args) do
    args
    |> map_get(
      :environment_mode,
      "environment_mode",
      map_get(args, :workspace_mode, "workspace_mode", map_get(args, :mode, "mode", "cloud"))
    )
    |> normalize_environment_mode()
  end

  defp environment_mode_from_args(_args), do: "cloud"

  defp workspace_state_from_args(args) when is_map(args) do
    explicit_state =
      args
      |> map_get(:workspace_state, "workspace_state")
      |> normalize_workspace_state()

    status_state =
      args
      |> map_get(:workspace_status, "workspace_status")
      |> normalize_workspace_state()

    clean_flag_state =
      args
      |> map_get(
        :workspace_clean,
        "workspace_clean",
        map_get(args, :workspace_is_clean, "workspace_is_clean")
      )
      |> normalize_workspace_clean_flag()

    explicit_state || status_state || clean_flag_state || "unknown"
  end

  defp workspace_state_from_args(_args), do: "unknown"

  defp normalize_environment_mode(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        "cloud"

      normalized_mode ->
        case String.downcase(normalized_mode) do
          "local" -> "local"
          "cloud" -> "cloud"
          "sprite" -> "cloud"
          _other -> "cloud"
        end
    end
  end

  defp normalize_workspace_state(value) when is_boolean(value),
    do: normalize_workspace_clean_flag(value)

  defp normalize_workspace_state(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_state ->
        case String.downcase(normalized_state) do
          "clean" -> "clean"
          "ready" -> "clean"
          "pristine" -> "clean"
          "dirty" -> "dirty"
          "modified" -> "dirty"
          "changes" -> "dirty"
          "changes_present" -> "dirty"
          _other -> nil
        end
    end
  end

  defp normalize_workspace_clean_flag(true), do: "clean"
  defp normalize_workspace_clean_flag(false), do: "dirty"

  defp normalize_workspace_clean_flag(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_value ->
        case String.downcase(normalized_value) do
          "true" -> "clean"
          "false" -> "dirty"
          "1" -> "clean"
          "0" -> "dirty"
          _other -> nil
        end
    end
  end

  defp normalize_optional_boolean(value) when is_boolean(value), do: value

  defp normalize_optional_boolean(value) do
    value
    |> normalize_optional_string()
    |> case do
      nil ->
        nil

      normalized_value ->
        case String.downcase(normalized_value) do
          "true" -> true
          "false" -> false
          "1" -> true
          "0" -> false
          _other -> nil
        end
    end
  end

  defp default_step_metadata do
    step_metadata(@workspace_policy_stage, @workspace_policy_operation)
  end

  defp step_metadata(stage, operation) do
    %{
      step: "CommitAndPR",
      stage: stage,
      operation: operation
    }
  end

  defp branch_setup_error(reason_type, detail, branch_context, reason \\ nil) do
    %{
      error_type: @branch_setup_error_type,
      operation: @branch_setup_operation,
      reason_type: normalize_reason_type(reason_type),
      detail: format_failure_detail(detail, reason),
      remediation: @branch_setup_remediation,
      blocked_stage: "commit_changes",
      halted_before_commit: true,
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      timestamp: timestamp_now()
    }
  end

  defp workspace_policy_error(
         reason_type,
         detail,
         branch_context,
         workspace_policy_check,
         reason \\ nil
       ) do
    %{
      error_type: @workspace_policy_error_type,
      operation: @workspace_policy_operation,
      reason_type: normalize_reason_type(reason_type),
      detail: format_failure_detail(detail, reason),
      remediation:
        workspace_policy_check
        |> map_get(:remediation, "remediation", @workspace_policy_remediation)
        |> normalize_optional_string() || @workspace_policy_remediation,
      blocked_stage: "commit_changes",
      blocked_actions: @blocked_shipping_actions,
      halted_before_commit: true,
      halted_before_push: true,
      halted_before_pr: true,
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      policy_check: normalize_map(workspace_policy_check),
      timestamp: timestamp_now()
    }
  end

  defp secret_scan_policy_error(
         reason_type,
         detail,
         branch_context,
         secret_scan_policy_check,
         reason
       ) do
    %{
      error_type: @secret_scan_policy_error_type,
      operation: @secret_scan_policy_operation,
      reason_type: normalize_reason_type(reason_type),
      detail: format_failure_detail(detail, reason),
      remediation:
        secret_scan_policy_check
        |> map_get(:remediation, "remediation", @secret_scan_policy_remediation)
        |> normalize_optional_string() || @secret_scan_policy_remediation,
      blocked_stage: "commit_changes",
      blocked_actions: @blocked_shipping_actions,
      halted_before_commit: true,
      halted_before_push: true,
      halted_before_pr: true,
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      policy_check: normalize_map(secret_scan_policy_check),
      timestamp: timestamp_now()
    }
  end

  defp diff_size_policy_error(
         reason_type,
         detail,
         branch_context,
         diff_size_policy_check,
         reason
       ) do
    blocked_actions =
      diff_size_policy_check
      |> map_get(:blocked_actions, "blocked_actions", @blocked_shipping_actions)
      |> case do
        actions when is_list(actions) -> actions
        _other -> @blocked_shipping_actions
      end

    %{
      error_type: @diff_size_policy_error_type,
      operation: @diff_size_policy_operation,
      reason_type: normalize_reason_type(reason_type),
      detail: format_failure_detail(detail, reason),
      remediation:
        diff_size_policy_check
        |> map_get(:remediation, "remediation", @diff_size_policy_remediation)
        |> normalize_optional_string() || @diff_size_policy_remediation,
      blocked_stage: "commit_changes",
      blocked_actions: blocked_actions,
      halted_before_commit: true,
      halted_before_push: true,
      halted_before_pr: true,
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      policy_check: normalize_map(diff_size_policy_check),
      timestamp: timestamp_now()
    }
  end

  defp binary_file_policy_error(
         reason_type,
         detail,
         branch_context,
         binary_file_policy_check,
         reason
       ) do
    blocked_actions =
      binary_file_policy_check
      |> map_get(:blocked_actions, "blocked_actions", @blocked_shipping_actions)
      |> case do
        actions when is_list(actions) -> actions
        _other -> @blocked_shipping_actions
      end

    %{
      error_type: @binary_file_policy_error_type,
      operation: @binary_file_policy_operation,
      reason_type: normalize_reason_type(reason_type),
      detail: format_failure_detail(detail, reason),
      remediation:
        binary_file_policy_check
        |> map_get(:remediation, "remediation", @binary_file_policy_remediation)
        |> normalize_optional_string() || @binary_file_policy_remediation,
      blocked_stage: "commit_changes",
      blocked_actions: blocked_actions,
      halted_before_commit: true,
      halted_before_push: true,
      halted_before_pr: true,
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      policy_check: normalize_map(binary_file_policy_check),
      timestamp: timestamp_now()
    }
  end

  defp commit_message_contract_error(
         reason_type,
         detail,
         branch_context,
         commit_message_check,
         reason \\ nil
       ) do
    blocked_actions =
      commit_message_check
      |> map_get(:blocked_actions, "blocked_actions", @blocked_shipping_actions)
      |> case do
        actions when is_list(actions) -> actions
        _other -> @blocked_shipping_actions
      end

    %{
      error_type: @commit_message_error_type,
      operation: @commit_message_operation,
      reason_type: normalize_reason_type(reason_type),
      detail: format_failure_detail(detail, reason),
      remediation:
        commit_message_check
        |> map_get(:remediation, "remediation", @commit_message_remediation)
        |> normalize_optional_string() || @commit_message_remediation,
      blocked_stage: "commit_changes",
      blocked_actions: blocked_actions,
      halted_before_commit: true,
      halted_before_push: true,
      halted_before_pr: true,
      branch_name: branch_context |> map_get(:branch_name, "branch_name") |> normalize_optional_string(),
      branch_derivation: branch_context |> map_get(:branch_derivation, "branch_derivation") |> normalize_map(),
      contract_check: normalize_map(commit_message_check),
      timestamp: timestamp_now()
    }
  end

  defp timestamp_now do
    DateTime.utc_now() |> DateTime.truncate(:second) |> DateTime.to_iso8601()
  end

  defp format_failure_detail(detail, nil), do: detail
  defp format_failure_detail(detail, ""), do: detail

  defp format_failure_detail(detail, reason) do
    "#{detail} (#{format_failure_reason(reason)})"
  end

  defp format_failure_reason(reason) when is_binary(reason), do: reason

  defp format_failure_reason(reason) do
    reason
    |> Exception.message()
    |> normalize_optional_string()
    |> case do
      nil -> inspect(reason)
      message -> message
    end
  rescue
    _exception -> inspect(reason)
  end

  defp normalize_reason_type(reason_type) do
    reason_type
    |> normalize_optional_string()
    |> case do
      nil -> "unknown"
      value -> String.replace(value, ~r/[^a-zA-Z0-9._-]/, "_")
    end
  end

  defp normalize_optional_string(nil), do: nil
  defp normalize_optional_string(value) when is_boolean(value), do: nil

  defp normalize_optional_string(value) when is_binary(value) do
    case String.trim(value) do
      "" -> nil
      normalized_value -> normalized_value
    end
  end

  defp normalize_optional_string(value) when is_atom(value),
    do: value |> Atom.to_string() |> normalize_optional_string()

  defp normalize_optional_string(value) when is_integer(value), do: Integer.to_string(value)
  defp normalize_optional_string(value) when is_float(value), do: :erlang.float_to_binary(value)
  defp normalize_optional_string(_value), do: nil

  defp normalize_map(%{} = map), do: map
  defp normalize_map(_value), do: %{}

  defp map_get(map, atom_key, string_key, default \\ nil)

  defp map_get(map, atom_key, string_key, default) when is_map(map) do
    cond do
      Map.has_key?(map, atom_key) -> Map.get(map, atom_key)
      Map.has_key?(map, string_key) -> Map.get(map, string_key)
      true -> default
    end
  end

  defp map_get(_map, _atom_key, _string_key, default), do: default
end
